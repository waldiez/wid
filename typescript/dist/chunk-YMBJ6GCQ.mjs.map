{"version":3,"sources":["../src/time.ts","../src/wid.ts","../src/hlc.ts","../src/manifest.ts"],"sourcesContent":["/** Supported time-precision units for WID/HLC generators. */\nexport type TimeUnit = \"sec\" | \"ms\";\n\nexport function parseTimeUnit(input: string): TimeUnit {\n  if (input === \"sec\" || input === \"ms\") {\n    return input;\n  }\n  throw new Error(\"time-unit must be sec or ms\");\n}\n\nexport function timeDigits(unit: TimeUnit): number {\n  return unit === \"ms\" ? 9 : 6;\n}\n","/**\n * WID (Waldiez/SYNAPSE Identifier) generation and validation.\n * Format: YYYYMMDDTHHMMSS[mmm].<seqW>Z[-<scope>][-<padZ>]\n */\n\nimport { type TimeUnit, timeDigits } from \"./time\";\n\n/** Parsed WID components after a successful parse. */\nexport interface ParsedWid {\n  /** Raw identifier string that was parsed. */\n  raw: string;\n  /** UTC timestamp extracted from the WID envelope. */\n  timestamp: Date;\n  /** Sequential component embedded in the identifier. */\n  sequence: number;\n  /** Optional scope suffix if one was provided. */\n  scope: string | null;\n  /** Optional padding hex string when Z > 0. */\n  padding: string | null;\n}\n\n/** In-memory snapshot of the last seen second/sequence for a generator. */\nexport interface WidStateSnapshot {\n  lastSec: number;\n  lastSeq: number;\n}\n\n/** Storage contract consumed by `WidGen` when persistence is enabled. */\nexport interface WidStateStore {\n  load(key: string): WidStateSnapshot | null;\n  save(key: string, state: WidStateSnapshot): void;\n}\n\n/** Basic in-memory store that keeps Wid state during runtime. */\nexport class MemoryWidStateStore implements WidStateStore {\n  private readonly memory = new Map<string, WidStateSnapshot>();\n\n  load(key: string): WidStateSnapshot | null {\n    const hit = this.memory.get(key);\n    return hit ? { ...hit } : null;\n  }\n\n  save(key: string, state: WidStateSnapshot): void {\n    this.memory.set(key, { ...state });\n  }\n}\n\n/** Browser localStorage-backed store; falls back to no-op outside browsers. */\nclass BrowserLocalStorageWidStateStore implements WidStateStore {\n  private readonly prefix: string;\n\n  constructor(prefix = \"wid\") {\n    this.prefix = prefix;\n  }\n\n  private keyOf(key: string): string {\n    return `${this.prefix}:${key}`;\n  }\n\n  private localStorageLike():\n    | { getItem: (k: string) => string | null; setItem: (k: string, v: string) => void }\n    | null {\n    const g = globalThis as unknown as Record<string, unknown>;\n    const ls = g.localStorage as\n      | { getItem: (k: string) => string | null; setItem: (k: string, v: string) => void }\n      | undefined;\n    return ls ?? null;\n  }\n\n  load(key: string): WidStateSnapshot | null {\n    const ls = this.localStorageLike();\n    if (!ls) return null;\n    const raw = ls.getItem(this.keyOf(key));\n    if (!raw) return null;\n    try {\n      const parsed = JSON.parse(raw) as Partial<WidStateSnapshot>;\n      if (\n        typeof parsed.lastSec === \"number\" &&\n        Number.isFinite(parsed.lastSec) &&\n        typeof parsed.lastSeq === \"number\" &&\n        Number.isFinite(parsed.lastSeq)\n      ) {\n        return { lastSec: parsed.lastSec, lastSeq: parsed.lastSeq };\n      }\n    } catch {\n      return null;\n    }\n    return null;\n  }\n\n  save(key: string, state: WidStateSnapshot): void {\n    const ls = this.localStorageLike();\n    if (!ls) return;\n    ls.setItem(this.keyOf(key), JSON.stringify(state));\n  }\n}\n\n/**\n * Creates a browser localStorage-backed state store.\n * In non-browser runtimes this behaves as a no-op store.\n */\n/** Factory that wires the browser storage-backed Wid store for web runtimes. */\nexport function createBrowserWidStateStore(prefix = \"wid\"): WidStateStore {\n  return new BrowserLocalStorageWidStateStore(prefix);\n}\n\n/** SQLite-backed store for Node environments that support `node:sqlite`. */\nclass NodeSqliteWidStateStore implements WidStateStore {\n  private readonly db: {\n    exec: (sql: string) => void;\n    prepare: (sql: string) => { get: (...args: unknown[]) => unknown; run: (...args: unknown[]) => unknown };\n    close?: () => void;\n  };\n  private readonly prefix: string;\n\n  constructor(databasePath: string, prefix = \"wid\") {\n    this.prefix = prefix;\n    /** Node sqlite constructor used for CLI persistence. */\n    const DatabaseSync = resolveNodeSqliteDatabaseSync();\n    this.db = new DatabaseSync(databasePath);\n    this.db.exec(\n      \"CREATE TABLE IF NOT EXISTS wid_state (k TEXT PRIMARY KEY, last_sec INTEGER NOT NULL, last_seq INTEGER NOT NULL)\"\n    );\n  }\n\n  private fullKey(key: string): string {\n    return `${this.prefix}:${key}`;\n  }\n\n  load(key: string): WidStateSnapshot | null {\n    const row = this.db\n      .prepare(\"SELECT last_sec, last_seq FROM wid_state WHERE k = ?\")\n      .get(this.fullKey(key)) as { last_sec?: number; last_seq?: number } | undefined;\n    if (!row) return null;\n    if (typeof row.last_sec !== \"number\" || typeof row.last_seq !== \"number\") return null;\n    return { lastSec: row.last_sec, lastSeq: row.last_seq };\n  }\n\n  save(key: string, state: WidStateSnapshot): void {\n    this.db\n      .prepare(\n        \"INSERT INTO wid_state (k, last_sec, last_seq) VALUES (?, ?, ?) ON CONFLICT(k) DO UPDATE SET last_sec=excluded.last_sec, last_seq=excluded.last_seq\"\n      )\n      .run(this.fullKey(key), state.lastSec, state.lastSeq);\n  }\n\n  close(): void {\n    this.db.close?.();\n  }\n}\n\nfunction resolveNodeSqliteDatabaseSync(): new (path: string) => {\n  exec: (sql: string) => void;\n  prepare: (sql: string) => { get: (...args: unknown[]) => unknown; run: (...args: unknown[]) => unknown };\n  close?: () => void;\n} {\n  const proc = (globalThis as { process?: unknown }).process as\n    | { versions?: { node?: string }; getBuiltinModule?: (name: string) => unknown }\n    | undefined;\n  if (!proc?.versions?.node) {\n    throw new Error(\"SQLite state store requires Node.js\");\n  }\n\n  const builtin = typeof proc.getBuiltinModule === \"function\" ? proc.getBuiltinModule(\"node:sqlite\") : null;\n  if (builtin && typeof builtin === \"object\" && \"DatabaseSync\" in builtin) {\n    return (builtin as { DatabaseSync: new (path: string) => NodeSqliteWidStateStore[\"db\"] }).DatabaseSync;\n  }\n\n  throw new Error(\"node:sqlite unavailable in this Node runtime\");\n}\n\n/** Node factory that requires the `node:sqlite` module for persistence. */\nexport function createNodeSqliteWidStateStore(databasePath: string, prefix = \"wid\"): WidStateStore {\n  return new NodeSqliteWidStateStore(databasePath, prefix);\n}\n\n/** Configuration options accepted by `WidGen`. */\nexport interface WidGenOptions {\n  /** Width of the sequence segment (default 4). */\n  W?: number;\n  /** Padding length (default 6). */\n  Z?: number;\n  /** Optional scope suffix appended to generated IDs. */\n  scope?: string;\n  /** Time unit precision, either `sec` or `ms`. */\n  timeUnit?: TimeUnit;\n  /** Optional persistence layer for generator state. */\n  stateStore?: WidStateStore;\n  /** Key used when storing state. */\n  stateKey?: string;\n  /** Persist state after each generation when true. */\n  autoPersist?: boolean;\n}\n\n/** Extended configuration for streaming helpers around `WidGen`. */\nexport interface AsyncWidStreamOptions extends WidGenOptions {\n  /** Number of IDs to emit (0 for infinite). */\n  count?: number;\n  /** Delay between emits in milliseconds. */\n  intervalMs?: number;\n}\n\n/** Cache of regex instances for base WID formats per width/unit. */\nconst WID_BASE_RE_CACHE = new Map<string, RegExp>();\n/** Cache for padding-hex validation patterns keyed by width. */\nconst HEX_RE_CACHE = new Map<number, RegExp>();\n/** Scope suffix pattern accepted by all generators. */\nconst SCOPE_PATTERN = /^[A-Za-z0-9_]+(?:-[A-Za-z0-9_]+)*$/;\n\nfunction widBaseRe(W: number, unit: TimeUnit): RegExp {\n  const key = `${W}:${unit}`;\n  const cached = WID_BASE_RE_CACHE.get(key);\n  if (cached) return cached;\n  const re = new RegExp(`^(\\\\d{8})T(\\\\d{${timeDigits(unit)}})\\\\.(\\\\d{${W}})Z(.*)?$`);\n  WID_BASE_RE_CACHE.set(key, re);\n  return re;\n}\n\nfunction hexRe(Z: number): RegExp {\n  const cached = HEX_RE_CACHE.get(Z);\n  if (cached) return cached;\n  const re = new RegExp(`^[0-9a-f]{${Z}}$`);\n  HEX_RE_CACHE.set(Z, re);\n  return re;\n}\n\nfunction bytesToHex(bytes: Uint8Array): string {\n  return Array.from(bytes, (b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\nfunction randomHexChars(Z: number): string {\n  if (!globalThis.crypto?.getRandomValues) {\n    throw new Error(\"Secure random generator unavailable in this runtime\");\n  }\n  const bytes = new Uint8Array(Math.ceil(Z / 2));\n  globalThis.crypto.getRandomValues(bytes);\n  return bytesToHex(bytes).slice(0, Z);\n}\n\nfunction parseSuffix(\n  suffix: string,\n  Z: number\n): { scope: string | null; padding: string | null } | null {\n  if (!suffix) {\n    return { scope: null, padding: null };\n  }\n\n  if (!suffix.startsWith(\"-\")) {\n    return null;\n  }\n\n  const body = suffix.slice(1);\n  if (!body) {\n    return null;\n  }\n\n  let scope: string | null = null;\n  let padding: string | null = null;\n\n  if (Z > 0) {\n    const splitAt = body.lastIndexOf(\"-\");\n    if (splitAt >= 0) {\n      const maybeScope = body.slice(0, splitAt);\n      const maybePadding = body.slice(splitAt + 1);\n      if (hexRe(Z).test(maybePadding)) {\n        padding = maybePadding;\n        scope = maybeScope || null;\n      } else if (maybePadding.length === Z && /^[0-9A-Fa-f]+$/.test(maybePadding)) {\n        return null;\n      } else {\n        scope = body;\n      }\n    } else if (hexRe(Z).test(body)) {\n      padding = body;\n    } else if (body.length === Z && /^[0-9A-Fa-f]+$/.test(body)) {\n      return null;\n    } else {\n      scope = body;\n    }\n  } else {\n    scope = body;\n  }\n\n  if (scope !== null && !SCOPE_PATTERN.test(scope)) {\n    return null;\n  }\n\n  if (padding !== null && !hexRe(Z).test(padding)) {\n    return null;\n  }\n\n  return { scope, padding };\n}\n\nfunction parseTimestamp(dateStr: string, timeStr: string, timeUnit: TimeUnit): Date | null {\n  const year = parseInt(dateStr.slice(0, 4), 10);\n  const month = parseInt(dateStr.slice(4, 6), 10);\n  const day = parseInt(dateStr.slice(6, 8), 10);\n  const hour = parseInt(timeStr.slice(0, 2), 10);\n  const minute = parseInt(timeStr.slice(2, 4), 10);\n  const second = parseInt(timeStr.slice(4, 6), 10);\n  const millis = timeUnit === \"ms\" ? parseInt(timeStr.slice(6, 9), 10) : 0;\n\n  if (month < 1 || month > 12) return null;\n  if (day < 1 || day > 31) return null;\n  if (hour > 23 || minute > 59 || second > 59) return null;\n  if (millis < 0 || millis > 999) return null;\n\n  const timestamp = new Date(Date.UTC(year, month - 1, day, hour, minute, second, millis));\n  if (isNaN(timestamp.getTime())) return null;\n  if (timestamp.getUTCDate() !== day || timestamp.getUTCMonth() + 1 !== month) return null;\n  return timestamp;\n}\n\nfunction parseCore(wid: string, W: number, Z: number, timeUnit: TimeUnit): ParsedWid | null {\n  if (W <= 0 || Z < 0) return null;\n\n  const match = widBaseRe(W, timeUnit).exec(wid);\n  if (!match) return null;\n\n  const [, dateStr, timeStr, seqStr, suffixRaw] = match;\n  const suffix = suffixRaw ?? \"\";\n\n  const timestamp = parseTimestamp(dateStr, timeStr, timeUnit);\n  if (!timestamp) return null;\n\n  const parsedSuffix = parseSuffix(suffix, Z);\n  if (!parsedSuffix) return null;\n\n  return {\n    raw: wid,\n    timestamp,\n    sequence: parseInt(seqStr, 10),\n    scope: parsedSuffix.scope,\n    padding: parsedSuffix.padding,\n  };\n}\n\nexport function validateWid(wid: string, W = 4, Z = 6, timeUnit: TimeUnit = \"sec\"): boolean {\n  return parseCore(wid, W, Z, timeUnit) !== null;\n}\n\nexport function parseWid(wid: string, W = 4, Z = 6, timeUnit: TimeUnit = \"sec\"): ParsedWid | null {\n  return parseCore(wid, W, Z, timeUnit);\n}\n\nexport async function asyncNextWid(options: WidGenOptions = {}): Promise<string> {\n  return new WidGen(options).next();\n}\n\nexport async function* asyncWidStream(\n  options: AsyncWidStreamOptions = {}\n): AsyncGenerator<string> {\n  const { count = 0, intervalMs = 0, ...genOpts } = options;\n  if (count < 0) throw new Error(\"count must be >= 0\");\n  if (intervalMs < 0) throw new Error(\"intervalMs must be >= 0\");\n\n  const gen = new WidGen(genOpts);\n  let emitted = 0;\n  while (count === 0 || emitted < count) {\n    yield gen.next();\n    emitted += 1;\n    if (intervalMs > 0) {\n      await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    }\n  }\n}\n\n/** Stateful generator for WID IDs that keeps monotonicity guarantees. */\nexport class WidGen {\n  private readonly W: number;\n  private readonly Z: number;\n  private readonly scope: string | null;\n  private readonly timeUnit: TimeUnit;\n  private readonly maxSeq: number;\n  private readonly stateStore: WidStateStore | null;\n  private readonly stateKey: string;\n  private readonly autoPersist: boolean;\n\n  private lastSec = 0;\n  private lastSeq = -1;\n  private cachedSec = -1;\n  private cachedTs = \"\";\n\n  /** Create a generator with optional persistence and precision control. */\n  constructor(options: WidGenOptions = {}) {\n    const {\n      W = 4,\n      Z = 6,\n      scope,\n      timeUnit = \"sec\",\n      stateStore,\n      stateKey = \"wid\",\n      autoPersist = false,\n    } = options;\n\n    if (W <= 0) throw new Error(\"W must be > 0\");\n    if (Z < 0) throw new Error(\"Z must be >= 0\");\n    if (scope && !SCOPE_PATTERN.test(scope)) {\n      throw new Error(\"Invalid scope format\");\n    }\n\n    this.W = W;\n    this.Z = Z;\n    this.scope = scope ?? null;\n    this.timeUnit = timeUnit;\n    this.maxSeq = Math.pow(10, W) - 1;\n    this.stateStore = stateStore ?? null;\n    this.stateKey = stateKey;\n    this.autoPersist = autoPersist;\n\n    if (this.autoPersist && this.stateStore) {\n      const loaded = this.stateStore.load(this.stateKey);\n      if (\n        loaded &&\n        Number.isFinite(loaded.lastSec) &&\n        Number.isFinite(loaded.lastSeq) &&\n        loaded.lastSec >= 0 &&\n        loaded.lastSeq >= -1\n      ) {\n        this.lastSec = loaded.lastSec;\n        this.lastSeq = loaded.lastSeq;\n      }\n    }\n  }\n\n  private persistState(): void {\n    if (!this.autoPersist || !this.stateStore) return;\n    try {\n      this.stateStore.save(this.stateKey, { lastSec: this.lastSec, lastSeq: this.lastSeq });\n    } catch {\n      // Keep generator functional even if persistence fails.\n    }\n  }\n\n  private tsForTick(tick: number): string {\n    if (tick !== this.cachedSec) {\n      this.cachedSec = tick;\n      const sec = this.timeUnit === \"ms\" ? Math.floor(tick / 1000) : tick;\n      const ms = this.timeUnit === \"ms\" ? tick % 1000 : 0;\n      const d = new Date(sec * 1000);\n      const year = d.getUTCFullYear();\n      const month = String(d.getUTCMonth() + 1).padStart(2, \"0\");\n      const day = String(d.getUTCDate()).padStart(2, \"0\");\n      const hour = String(d.getUTCHours()).padStart(2, \"0\");\n      const minute = String(d.getUTCMinutes()).padStart(2, \"0\");\n      const second = String(d.getUTCSeconds()).padStart(2, \"0\");\n      const milli = String(ms).padStart(3, \"0\");\n      this.cachedTs =\n        this.timeUnit === \"ms\"\n          ? `${year}${month}${day}T${hour}${minute}${second}${milli}`\n          : `${year}${month}${day}T${hour}${minute}${second}`;\n    }\n    return this.cachedTs;\n  }\n\n  private nowTick(): number {\n    if (this.timeUnit === \"ms\") {\n      return Date.now();\n    }\n    return Math.floor(Date.now() / 1000);\n  }\n\n  next(): string {\n    const now = this.nowTick();\n    let tick = now > this.lastSec ? now : this.lastSec;\n    let seq = tick === this.lastSec ? this.lastSeq + 1 : 0;\n\n    if (seq > this.maxSeq) {\n      tick += 1;\n      seq = 0;\n    }\n\n    this.lastSec = tick;\n    this.lastSeq = seq;\n\n    const ts = this.tsForTick(tick);\n    const seqStr = String(seq).padStart(this.W, \"0\");\n    let wid = `${ts}.${seqStr}Z`;\n\n    if (this.scope) {\n      wid += `-${this.scope}`;\n    }\n\n    if (this.Z > 0) {\n      wid += `-${randomHexChars(this.Z)}`;\n    }\n\n    this.persistState();\n    return wid;\n  }\n\n  nextN(n: number): string[] {\n    return Array.from({ length: n }, () => this.next());\n  }\n\n  get state(): WidStateSnapshot {\n    return { lastSec: this.lastSec, lastSeq: this.lastSeq };\n  }\n\n  restoreState(lastSec: number, lastSeq: number): void {\n    this.lastSec = lastSec;\n    this.lastSeq = lastSeq;\n    this.persistState();\n  }\n}\n","/**\n * HLC-WID (Hybrid Logical Clock WID) generation, validation, and parsing.\n * Format: YYYYMMDDTHHMMSS[mmm].<lcW>Z-<node>[-<padZ>]\n */\n\nimport { type TimeUnit, timeDigits } from \"./time\";\n\n/** Parsed components of an HLC-WID after a successful parse. */\nexport interface ParsedHlcWid {\n  /** Raw HLC-WID string. */\n  raw: string;\n  /** UTC timestamp portion of the HLC-WID. */\n  timestamp: Date;\n  /** Logical clock counter embedded in the HLC-WID. */\n  logicalCounter: number;\n  /** Node identifier appended to the HLC-WID. */\n  node: string;\n  /** Optional padding when Z > 0. */\n  padding: string | null;\n}\n\n/** Minimal Hybrid Logical Clock state snapshot. */\nexport interface HLCState {\n  /** Physical timestamp used by the generator. */\n  pt: number;\n  /** Logical counter component. */\n  lc: number;\n}\n\n/** Configuration options for `HLCWidGen`. */\nexport interface HLCWidGenOptions {\n  /** Unique node identifier suffix. */\n  node: string;\n  /** Width of the logical counter (default 4). */\n  W?: number;\n  /** Optional padding length (default 0). */\n  Z?: number;\n  /** Time precision (defaults to `sec`). */\n  timeUnit?: TimeUnit;\n}\n\n/** Cache for HLC-WID regex instances per width/time unit pair. */\nconst HLC_BASE_RE_CACHE = new Map<string, RegExp>();\n/** Cache for hex validation patterns keyed by padding length. */\nconst HEX_RE_CACHE = new Map<number, RegExp>();\n/** Node identifier pattern reused by HLC generators. */\nconst NODE_RE = /^[A-Za-z0-9_]+$/;\n\nfunction hlcBaseRe(W: number, unit: TimeUnit): RegExp {\n  const key = `${W}:${unit}`;\n  const cached = HLC_BASE_RE_CACHE.get(key);\n  if (cached) return cached;\n  const re = new RegExp(`^(\\\\d{8})T(\\\\d{${timeDigits(unit)}})\\\\.(\\\\d{${W}})Z-([A-Za-z0-9_]+)(.*)$`);\n  HLC_BASE_RE_CACHE.set(key, re);\n  return re;\n}\n\nfunction hexRe(Z: number): RegExp {\n  const cached = HEX_RE_CACHE.get(Z);\n  if (cached) return cached;\n  const re = new RegExp(`^[0-9a-f]{${Z}}$`);\n  HEX_RE_CACHE.set(Z, re);\n  return re;\n}\n\nfunction randomHexChars(Z: number): string {\n  if (!globalThis.crypto?.getRandomValues) {\n    throw new Error(\"Secure random generator unavailable in this runtime\");\n  }\n  const bytes = new Uint8Array(Math.ceil(Z / 2));\n  globalThis.crypto.getRandomValues(bytes);\n  return Array.from(bytes, (b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\")\n    .slice(0, Z);\n}\n\nfunction isValidNode(node: string): boolean {\n  return NODE_RE.test(node);\n}\n\nfunction parseTimestamp(dateStr: string, timeStr: string, timeUnit: TimeUnit): Date | null {\n  const year = parseInt(dateStr.slice(0, 4), 10);\n  const month = parseInt(dateStr.slice(4, 6), 10);\n  const day = parseInt(dateStr.slice(6, 8), 10);\n  const hour = parseInt(timeStr.slice(0, 2), 10);\n  const minute = parseInt(timeStr.slice(2, 4), 10);\n  const second = parseInt(timeStr.slice(4, 6), 10);\n  const millis = timeUnit === \"ms\" ? parseInt(timeStr.slice(6, 9), 10) : 0;\n\n  if (month < 1 || month > 12) return null;\n  if (day < 1 || day > 31) return null;\n  if (hour > 23 || minute > 59 || second > 59) return null;\n  if (millis < 0 || millis > 999) return null;\n\n  const timestamp = new Date(Date.UTC(year, month - 1, day, hour, minute, second, millis));\n  if (isNaN(timestamp.getTime())) return null;\n  if (timestamp.getUTCDate() !== day || timestamp.getUTCMonth() + 1 !== month) return null;\n  return timestamp;\n}\n\nexport function validateHlcWid(\n  wid: string,\n  W = 4,\n  Z = 0,\n  timeUnit: TimeUnit = \"sec\"\n): boolean {\n  return parseHlcWid(wid, W, Z, timeUnit) !== null;\n}\n\nexport function parseHlcWid(\n  wid: string,\n  W = 4,\n  Z = 0,\n  timeUnit: TimeUnit = \"sec\"\n): ParsedHlcWid | null {\n  if (W <= 0 || Z < 0) return null;\n\n  const match = hlcBaseRe(W, timeUnit).exec(wid);\n  if (!match) return null;\n\n  const [, dateStr, timeStr, lcStr, node, suffixRaw] = match;\n  const suffix = suffixRaw ?? \"\";\n\n  if (!isValidNode(node)) return null;\n\n  const timestamp = parseTimestamp(dateStr, timeStr, timeUnit);\n  if (!timestamp) return null;\n\n  const logicalCounter = parseInt(lcStr, 10);\n\n  let padding: string | null = null;\n  if (suffix) {\n    if (!suffix.startsWith(\"-\")) return null;\n    const seg = suffix.slice(1);\n    if (Z === 0) return null;\n    if (!hexRe(Z).test(seg)) return null;\n    padding = seg;\n  }\n\n  return { raw: wid, timestamp, logicalCounter, node, padding };\n}\n\n/** Generator for HLC-WIDs that keeps the logical counter monotonic. */\nexport class HLCWidGen {\n  private readonly W: number;\n  private readonly Z: number;\n  private readonly node: string;\n  private readonly timeUnit: TimeUnit;\n  private readonly maxLC: number;\n  private pt = 0;\n  private lc = 0;\n  private cachedTick = -1;\n  private cachedTs = \"\";\n\n  constructor(options: HLCWidGenOptions) {\n    const { node, W = 4, Z = 0, timeUnit = \"sec\" } = options;\n    if (W <= 0) throw new Error(\"W must be > 0\");\n    if (Z < 0) throw new Error(\"Z must be >= 0\");\n    if (!isValidNode(node)) {\n      throw new Error(\"node must match [A-Za-z0-9_]+\");\n    }\n    this.W = W;\n    this.Z = Z;\n    this.node = node;\n    this.timeUnit = timeUnit;\n    this.maxLC = Math.pow(10, W) - 1;\n  }\n\n  private nowTick(): number {\n    if (this.timeUnit === \"ms\") {\n      return Date.now();\n    }\n    return Math.floor(Date.now() / 1000);\n  }\n\n  private tsForTick(tick: number): string {\n    if (tick !== this.cachedTick) {\n      this.cachedTick = tick;\n      const sec = this.timeUnit === \"ms\" ? Math.floor(tick / 1000) : tick;\n      const ms = this.timeUnit === \"ms\" ? tick % 1000 : 0;\n      const d = new Date(sec * 1000);\n      const year = d.getUTCFullYear();\n      const mo = String(d.getUTCMonth() + 1).padStart(2, \"0\");\n      const dy = String(d.getUTCDate()).padStart(2, \"0\");\n      const hr = String(d.getUTCHours()).padStart(2, \"0\");\n      const mi = String(d.getUTCMinutes()).padStart(2, \"0\");\n      const sc = String(d.getUTCSeconds()).padStart(2, \"0\");\n      const milli = String(ms).padStart(3, \"0\");\n      this.cachedTs =\n        this.timeUnit === \"ms\"\n          ? `${year}${mo}${dy}T${hr}${mi}${sc}${milli}`\n          : `${year}${mo}${dy}T${hr}${mi}${sc}`;\n    }\n    return this.cachedTs;\n  }\n\n  private rollover(): void {\n    if (this.lc > this.maxLC) {\n      this.pt += 1;\n      this.lc = 0;\n    }\n  }\n\n  observe(remotePT: number, remoteLC: number): void {\n    if (remotePT < 0 || remoteLC < 0) {\n      throw new Error(\"remote values must be non-negative\");\n    }\n    const now = this.nowTick();\n    const newPT = Math.max(now, this.pt, remotePT);\n\n    if (newPT === this.pt && newPT === remotePT) {\n      this.lc = Math.max(this.lc, remoteLC) + 1;\n    } else if (newPT === this.pt) {\n      this.lc += 1;\n    } else if (newPT === remotePT) {\n      this.lc = remoteLC + 1;\n    } else {\n      this.lc = 0;\n    }\n    this.pt = newPT;\n    this.rollover();\n  }\n\n  next(): string {\n    const now = this.nowTick();\n    if (now > this.pt) {\n      this.pt = now;\n      this.lc = 0;\n    } else {\n      this.lc += 1;\n    }\n    this.rollover();\n\n    const ts = this.tsForTick(this.pt);\n    const lcStr = String(this.lc).padStart(this.W, \"0\");\n    let wid = `${ts}.${lcStr}Z-${this.node}`;\n    if (this.Z > 0) {\n      wid += `-${randomHexChars(this.Z)}`;\n    }\n    return wid;\n  }\n\n  nextN(n: number): string[] {\n    return Array.from({ length: n }, () => this.next());\n  }\n\n  get state(): HLCState {\n    return { pt: this.pt, lc: this.lc };\n  }\n\n  restoreState(pt: number, lc: number): void {\n    if (pt < 0 || lc < 0) throw new Error(\"invalid state\");\n    this.pt = pt;\n    this.lc = lc;\n  }\n}\n\nexport async function asyncNextHlcWid(options: HLCWidGenOptions): Promise<string> {\n  return new HLCWidGen(options).next();\n}\n\nexport async function* asyncHlcWidStream(\n  options: HLCWidGenOptions & { count?: number; intervalMs?: number }\n): AsyncGenerator<string> {\n  const { count = 0, intervalMs = 0, ...genOpts } = options;\n  if (count < 0) throw new Error(\"count must be >= 0\");\n  if (intervalMs < 0) throw new Error(\"intervalMs must be >= 0\");\n  const gen = new HLCWidGen(genOpts);\n  let emitted = 0;\n  while (count === 0 || emitted < count) {\n    yield gen.next();\n    emitted++;\n    if (intervalMs > 0) {\n      await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    }\n  }\n}\n","/**\n * SYNAPSE Manifest-Based Binary Files.\n */\n\n/** Fixed header bytes used by SYNAPSE files. */\nexport const MANIFEST_MAGIC = new Uint8Array([0x53, 0x59, 0x4e, 0x4d]); // SYNM\n/** Current manifest version published in all files. */\nexport const MANIFEST_VERSION = 1;\n/** Maximum allowed manifest payload size in bytes. */\nexport const MAX_MANIFEST_SIZE = 64 * 1024;\n/** Length of the SYNAPSE file header (magic + version + length). */\nconst HEADER_SIZE = 10;\n\n/** Supported data media types stored inside a manifest. */\nexport enum DataType {\n  Unknown = 'unknown',\n  Text = 'text/plain',\n  Json = 'application/json',\n  Binary = 'application/octet-stream',\n}\n\n/** Shape of a manifest when decoding/encoding JSON representations. */\nexport interface ManifestData {\n  id: string;\n  version?: number;\n  node?: string;\n  data_type?: string;\n  data_size?: number;\n  data_hash?: string;\n  metadata?: Record<string, unknown>;\n}\n\nfunction concatBytes(parts: Uint8Array[]): Uint8Array {\n  const total = parts.reduce((acc, p) => acc + p.length, 0);\n  const out = new Uint8Array(total);\n  let offset = 0;\n  for (const p of parts) {\n    out.set(p, offset);\n    offset += p.length;\n  }\n  return out;\n}\n\nfunction equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction toHex(bytes: Uint8Array): string {\n  return Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');\n}\n\nasync function sha256Hex(data: Uint8Array): Promise<string> {\n  if (!globalThis.crypto?.subtle) {\n    throw new Error('Web Crypto API (crypto.subtle) is unavailable in this runtime');\n  }\n  // @ts-expect-error sth with Uint8Array\n  const digest = await globalThis.crypto.subtle.digest('SHA-256', data);\n  return toHex(new Uint8Array(digest));\n}\n\nfunction utf8Encode(s: string): Uint8Array {\n  return new TextEncoder().encode(s);\n}\n\nfunction utf8Decode(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Lightweight wrapper around manifest metadata with serialization helpers. */\nexport class Manifest {\n  id: string;\n  version: number;\n  node: string;\n  data_type: string;\n  data_size: number;\n  data_hash: string;\n  metadata: Record<string, unknown>;\n\n  constructor(data: ManifestData) {\n    this.id = data.id;\n    this.version = data.version ?? MANIFEST_VERSION;\n    this.node = data.node ?? '';\n    this.data_type = data.data_type ?? DataType.Unknown;\n    this.data_size = data.data_size ?? 0;\n    this.data_hash = data.data_hash ?? '';\n    this.metadata = data.metadata ?? {};\n  }\n\n  toJson(): string {\n    return JSON.stringify(this, null, 2);\n  }\n\n  toBytes(): Uint8Array {\n    return utf8Encode(this.toJson());\n  }\n\n  static fromJson(data: string): Manifest {\n    return new Manifest(JSON.parse(data));\n  }\n\n  static fromBytes(data: Uint8Array): Manifest {\n    return Manifest.fromJson(utf8Decode(data));\n  }\n}\n\n/** Composite object combining a manifest with its binary payload. */\nexport class SynapseFile {\n  manifest: Manifest;\n  payload: Uint8Array;\n\n  constructor(manifest: Manifest, payload: Uint8Array = new Uint8Array(0)) {\n    this.manifest = manifest;\n    this.payload = payload;\n  }\n\n  async toBytes(): Promise<Uint8Array> {\n    this.manifest.data_size = this.payload.length;\n    this.manifest.data_hash = await sha256Hex(this.payload);\n\n    const manifestBytes = this.manifest.toBytes();\n    if (manifestBytes.length > MAX_MANIFEST_SIZE) {\n      throw new Error(`Manifest too large: ${manifestBytes.length} bytes`);\n    }\n\n    const header = new Uint8Array(HEADER_SIZE);\n    header.set(MANIFEST_MAGIC, 0);\n    const view = new DataView(header.buffer, header.byteOffset, header.byteLength);\n    view.setUint16(4, MANIFEST_VERSION, false);\n    view.setUint32(6, manifestBytes.length, false);\n\n    return concatBytes([header, manifestBytes, this.payload]);\n  }\n\n  static fromBytes(data: Uint8Array): SynapseFile {\n    if (data.length < HEADER_SIZE) {\n      throw new Error('Data too small for SYNAPSE file');\n    }\n\n    const magic = data.subarray(0, 4);\n    if (!equalBytes(magic, MANIFEST_MAGIC)) {\n      throw new Error(`Invalid magic: ${utf8Decode(magic)}`);\n    }\n\n    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    const manifestSize = view.getUint32(6, false);\n    if (manifestSize > MAX_MANIFEST_SIZE) {\n      throw new Error(`Manifest too large: ${manifestSize} bytes`);\n    }\n\n    const manifestEnd = HEADER_SIZE + manifestSize;\n    const manifestBytes = data.subarray(HEADER_SIZE, manifestEnd);\n    const manifest = Manifest.fromBytes(manifestBytes);\n    const payload = data.subarray(manifestEnd);\n\n    return new SynapseFile(manifest, payload);\n  }\n\n  async verify(): Promise<boolean> {\n    const actualHash = await sha256Hex(this.payload);\n    return actualHash === this.manifest.data_hash;\n  }\n}\n"],"mappings":"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","names":["HEX_RE_CACHE","hexRe","randomHexChars","parseTimestamp","DataType"]}