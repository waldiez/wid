{"version":3,"sources":["../typescript/src/cli.ts","../typescript/src/time.ts","../typescript/src/wid.ts","../typescript/src/hlc.ts","../typescript/src/manifest.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { closeSync, existsSync, mkdirSync, openSync, readFileSync, unlinkSync, writeFileSync } from \"node:fs\";\nimport { dirname, resolve } from \"node:path\";\nimport { spawn } from \"node:child_process\";\nimport { createHmac, createPrivateKey, createPublicKey, sign as cryptoSign, timingSafeEqual, verify as cryptoVerify } from \"node:crypto\";\nimport {\n  HLCWidGen,\n  parseHlcWid,\n  parseWid,\n  validateHlcWid,\n  validateWid,\n  WidGen,\n} from \"./index\";\nimport { parseTimeUnit, type TimeUnit } from \"./time\";\n\n/** CLI mode selector for WID vs HLC workflows. */\ntype Kind = \"wid\" | \"hlc\";\n\n/** Parsed CLI options that drive each command. */\ninterface Opts {\n  /** Operation kind (wid or hlc). */\n  kind: Kind;\n  node: string;\n  W: number;\n  Z: number;\n  timeUnit: TimeUnit;\n  count: number;\n  json: boolean;\n}\n\n/** Canonical mode parameters sent on CLI helpers. */\ninterface Canon {\n  A: string;\n  W: number;\n  L: number;\n  D: string;\n  I: string;\n  E: string;\n  Z: number;\n  T: TimeUnit;\n  R: string;\n  M: boolean;\n  N: number;\n  WID?: string;\n  KEY?: string;\n  SIG?: string;\n  DATA?: string;\n  OUT?: string;\n  MODE?: string;\n  CODE?: string;\n  DIGITS?: number;\n  MAX_AGE_SEC?: number;\n  MAX_FUTURE_SEC?: number;\n}\n\n/** Allowed transports recognized by the CLI. */\nconst LOCAL_SERVICE_TRANSPORTS = new Set([\"mqtt\", \"ws\", \"redis\", \"null\", \"stdout\"]);\n\nfunction printHelp(): void {\n  console.error(`wid - WID/HLC-WID generator CLI\n\nUsage:\n  wid next [--kind wid|hlc] [--node <name>] [--W <n>] [--Z <n>] [--time-unit sec|ms]\n  wid stream [--kind wid|hlc] [--node <name>] [--W <n>] [--Z <n>] [--time-unit sec|ms] [--count <n>]\n  wid validate <id> [--kind wid|hlc] [--W <n>] [--Z <n>] [--time-unit sec|ms]\n  wid parse <id> [--kind wid|hlc] [--W <n>] [--Z <n>] [--time-unit sec|ms] [--json]\n  wid healthcheck [--kind wid|hlc] [--node <name>] [--W <n>] [--Z <n>] [--time-unit sec|ms] [--json]\n  wid bench [--kind wid|hlc] [--node <name>] [--W <n>] [--Z <n>] [--time-unit sec|ms] [--count <n>]\n\nCanonical mode:\n  wid W=# A=# L=# D=# I=# E=# Z=# T=sec|ms R=auto|mqtt|ws|redis|null|stdout N=#\n  wid A=w-otp MODE=gen|verify KEY=<secret|path> [WID=<wid>] [CODE=<otp>] [DIGITS=6] [MAX_AGE_SEC=0] [MAX_FUTURE_SEC=5]\n  For A=stream: N=0 means infinite stream\n  E supports: state | stateless | sql`);\n}\n\nfunction printActions(): void {\n  console.log(`wid action matrix\n\nCore ID:\n  A=next | A=stream | A=healthcheck | A=sign | A=verify | A=w-otp\n\nService lifecycle (native):\n  A=discover | A=scaffold | A=run | A=start | A=stop | A=status | A=logs\n\nService modules (native):\n  A=saf      (alias: raf)\n  A=saf-wid  (aliases: waf, wraf)\n  A=wir      (alias: witr)\n  A=wism     (alias: wim)\n  A=wihp     (alias: wih)\n  A=wipr     (alias: wip)\n  A=duplex\n\nHelp:\n  A=help-actions`);\n}\n\nfunction parseIntStrict(value: string, name: string): number {\n  const n = Number.parseInt(value, 10);\n  if (!Number.isFinite(n) || Number.isNaN(n)) throw new Error(`invalid integer for ${name}`);\n  return n;\n}\n\nfunction parseOpts(args: string[], allowCount: boolean): Opts {\n  const opts: Opts = {\n    kind: \"wid\",\n    node: process.env.NODE ?? \"ts\",\n    W: 4,\n    Z: 6,\n    timeUnit: \"sec\",\n    count: 0,\n    json: false,\n  };\n\n  for (let i = 0; i < args.length; i += 1) {\n    const arg = args[i];\n    switch (arg) {\n      case \"--kind\":\n        if (i + 1 >= args.length) throw new Error(\"missing value for --kind\");\n        opts.kind = args[++i] as Kind;\n        break;\n      case \"--node\":\n        if (i + 1 >= args.length) throw new Error(\"missing value for --node\");\n        opts.node = args[++i];\n        break;\n      case \"--W\":\n        if (i + 1 >= args.length) throw new Error(\"missing value for --W\");\n        opts.W = parseIntStrict(args[++i], \"--W\");\n        break;\n      case \"--Z\":\n        if (i + 1 >= args.length) throw new Error(\"missing value for --Z\");\n        opts.Z = parseIntStrict(args[++i], \"--Z\");\n        break;\n      case \"--time-unit\":\n      case \"--T\":\n        if (i + 1 >= args.length) throw new Error(\"missing value for --time-unit\");\n        opts.timeUnit = parseTimeUnit(args[++i]);\n        break;\n      case \"--count\":\n        if (!allowCount) throw new Error(\"unknown flag: --count\");\n        if (i + 1 >= args.length) throw new Error(\"missing value for --count\");\n        opts.count = parseIntStrict(args[++i], \"--count\");\n        break;\n      case \"--json\":\n        opts.json = true;\n        break;\n      default:\n        throw new Error(`unknown flag: ${arg}`);\n    }\n  }\n\n  if (opts.kind !== \"wid\" && opts.kind !== \"hlc\") throw new Error(\"--kind must be one of: wid, hlc\");\n  if (opts.W <= 0) throw new Error(\"W must be > 0\");\n  if (opts.Z < 0) throw new Error(\"Z must be >= 0\");\n  if (opts.count < 0) throw new Error(\"count must be >= 0\");\n  return opts;\n}\n\nfunction runNext(args: string[]): void {\n  const opts = parseOpts(args, false);\n  if (opts.kind === \"wid\") {\n    console.log(new WidGen({ W: opts.W, Z: opts.Z, timeUnit: opts.timeUnit }).next());\n    return;\n  }\n  console.log(new HLCWidGen({ node: opts.node, W: opts.W, Z: opts.Z, timeUnit: opts.timeUnit }).next());\n}\n\nfunction runStream(args: string[]): void {\n  const opts = parseOpts(args, true);\n  if (opts.kind === \"wid\") {\n    const gen = new WidGen({ W: opts.W, Z: opts.Z, timeUnit: opts.timeUnit });\n    for (let i = 0; opts.count === 0 || i < opts.count; i += 1) console.log(gen.next());\n    return;\n  }\n  const gen = new HLCWidGen({ node: opts.node, W: opts.W, Z: opts.Z, timeUnit: opts.timeUnit });\n  for (let i = 0; opts.count === 0 || i < opts.count; i += 1) console.log(gen.next());\n}\n\nfunction runValidate(args: string[]): void {\n  if (args.length === 0) throw new Error(\"validate requires an id\");\n  const id = args[0];\n  const opts = parseOpts(args.slice(1), false);\n  const ok =\n    opts.kind === \"wid\"\n      ? validateWid(id, opts.W, opts.Z, opts.timeUnit)\n      : validateHlcWid(id, opts.W, opts.Z, opts.timeUnit);\n  console.log(ok ? \"true\" : \"false\");\n  if (!ok) throw new Error(\"invalid wid\");\n}\n\nfunction runParse(args: string[]): void {\n  if (args.length === 0) throw new Error(\"parse requires an id\");\n  const id = args[0];\n  const opts = parseOpts(args.slice(1), false);\n\n  if (opts.kind === \"wid\") {\n    const parsed = parseWid(id, opts.W, opts.Z, opts.timeUnit);\n    if (!parsed) {\n      console.log(\"null\");\n      throw new Error(\"invalid wid\");\n    }\n    if (opts.json) {\n      console.log(\n        JSON.stringify({\n          raw: parsed.raw,\n          timestamp: parsed.timestamp.toISOString(),\n          sequence: parsed.sequence,\n          padding: parsed.padding,\n        })\n      );\n      return;\n    }\n    console.log(`raw=${parsed.raw}`);\n    console.log(`timestamp=${parsed.timestamp.toISOString()}`);\n    console.log(`sequence=${parsed.sequence}`);\n    console.log(`padding=${parsed.padding ?? \"\"}`);\n    return;\n  }\n\n  const parsed = parseHlcWid(id, opts.W, opts.Z, opts.timeUnit);\n  if (!parsed) {\n    console.log(\"null\");\n    throw new Error(\"invalid wid\");\n  }\n  if (opts.json) {\n    console.log(\n      JSON.stringify({\n        raw: parsed.raw,\n        timestamp: parsed.timestamp.toISOString(),\n        logical_counter: parsed.logicalCounter,\n        node: parsed.node,\n        padding: parsed.padding,\n      })\n    );\n    return;\n  }\n  console.log(`raw=${parsed.raw}`);\n  console.log(`timestamp=${parsed.timestamp.toISOString()}`);\n  console.log(`logical_counter=${parsed.logicalCounter}`);\n  console.log(`node=${parsed.node}`);\n  console.log(`padding=${parsed.padding ?? \"\"}`);\n}\n\nfunction runHealthcheck(args: string[]): void {\n  const opts = parseOpts(args, false);\n  const sample =\n    opts.kind === \"wid\"\n      ? new WidGen({ W: opts.W, Z: opts.Z, timeUnit: opts.timeUnit }).next()\n      : new HLCWidGen({ node: opts.node, W: opts.W, Z: opts.Z, timeUnit: opts.timeUnit }).next();\n\n  const ok =\n    opts.kind === \"wid\"\n      ? validateWid(sample, opts.W, opts.Z, opts.timeUnit)\n      : validateHlcWid(sample, opts.W, opts.Z, opts.timeUnit);\n\n  if (opts.json) {\n    console.log(\n      JSON.stringify({\n        ok,\n        kind: opts.kind,\n        W: opts.W,\n        Z: opts.Z,\n        time_unit: opts.timeUnit,\n        sample_id: sample,\n      })\n    );\n  } else {\n    console.log(`ok=${ok ? \"true\" : \"false\"} kind=${opts.kind} sample=${sample}`);\n  }\n\n  if (!ok) throw new Error(\"healthcheck failed\");\n}\n\nfunction runBench(args: string[]): void {\n  const opts = parseOpts(args, true);\n  const n = opts.count > 0 ? opts.count : 100000;\n\n  const start = process.hrtime.bigint();\n  if (opts.kind === \"wid\") {\n    const g = new WidGen({ W: opts.W, Z: opts.Z, timeUnit: opts.timeUnit });\n    for (let i = 0; i < n; i += 1) g.next();\n  } else {\n    const g = new HLCWidGen({ node: opts.node, W: opts.W, Z: opts.Z, timeUnit: opts.timeUnit });\n    for (let i = 0; i < n; i += 1) g.next();\n  }\n  const secs = Number(process.hrtime.bigint() - start) / 1_000_000_000;\n  const s = Math.max(secs, 1e-9);\n  console.log(\n    JSON.stringify({\n      impl: \"typescript\",\n      kind: opts.kind,\n      W: opts.W,\n      Z: opts.Z,\n      time_unit: opts.timeUnit,\n      n,\n      seconds: s,\n      ids_per_sec: n / s,\n    })\n  );\n}\n\nfunction parseCanonical(args: string[]): Canon {\n  const out: Canon = {\n    A: \"next\",\n    W: 4,\n    L: 3600,\n    D: \"\",\n    I: \"auto\",\n    E: \"state\",\n    Z: 6,\n    T: \"sec\",\n    R: \"auto\",\n    M: false,\n    N: 0,\n  };\n\n  for (const arg of args) {\n    const [k, vRaw] = arg.split(\"=\", 2);\n    if (!vRaw) throw new Error(`expected KEY=VALUE, got '${arg}'`);\n    const v = vRaw === \"#\" ? defaultValueFor(k) : vRaw;\n\n    switch (k) {\n      case \"A\":\n        out.A = v.toLowerCase();\n        break;\n      case \"W\":\n        out.W = parseIntStrict(v, \"W\");\n        break;\n      case \"L\":\n        out.L = parseIntStrict(v, \"L\");\n        break;\n      case \"D\":\n        out.D = v;\n        break;\n      case \"I\":\n        out.I = v;\n        break;\n      case \"E\":\n        out.E = v;\n        break;\n      case \"Z\":\n        out.Z = parseIntStrict(v, \"Z\");\n        break;\n      case \"T\":\n        out.T = parseTimeUnit(v);\n        break;\n      case \"R\":\n        out.R = v;\n        break;\n      case \"M\":\n        out.M = [\"1\", \"true\", \"yes\", \"y\", \"on\"].includes(v.toLowerCase());\n        break;\n      case \"N\":\n        out.N = parseIntStrict(v, \"N\");\n        break;\n      case \"WID\":\n        out.WID = v;\n        break;\n      case \"KEY\":\n        out.KEY = v;\n        break;\n      case \"SIG\":\n        out.SIG = v;\n        break;\n      case \"DATA\":\n        out.DATA = v;\n        break;\n      case \"OUT\":\n        out.OUT = v;\n        break;\n      case \"MODE\":\n        out.MODE = v;\n        break;\n      case \"CODE\":\n        out.CODE = v;\n        break;\n      case \"DIGITS\":\n        out.DIGITS = parseIntStrict(v, \"DIGITS\");\n        break;\n      case \"MAX_AGE_SEC\":\n        out.MAX_AGE_SEC = parseIntStrict(v, \"MAX_AGE_SEC\");\n        break;\n      case \"MAX_FUTURE_SEC\":\n        out.MAX_FUTURE_SEC = parseIntStrict(v, \"MAX_FUTURE_SEC\");\n        break;\n      default:\n        throw new Error(`unknown key: ${k}`);\n    }\n  }\n\n  if (out.M) out.T = \"ms\";\n\n  out.A =\n    out.A === \"id\" || out.A === \"default\"\n      ? \"next\"\n      : out.A === \"hc\"\n      ? \"healthcheck\"\n      : out.A === \"raf\"\n      ? \"saf\"\n      : out.A === \"waf\" || out.A === \"wraf\"\n      ? \"saf-wid\"\n      : out.A === \"witr\"\n      ? \"wir\"\n      : out.A === \"wim\"\n      ? \"wism\"\n      : out.A === \"wih\"\n      ? \"wihp\"\n      : out.A === \"wip\"\n      ? \"wipr\"\n      : out.A;\n\n  if (out.W <= 0) throw new Error(\"W must be > 0\");\n  if (out.Z < 0 || out.N < 0 || out.L < 0) throw new Error(\"Z/N/L must be >= 0\");\n  if (![\"auto\", \"mqtt\", \"ws\", \"redis\", \"null\", \"stdout\"].includes(out.R)) {\n    throw new Error(\"invalid R transport\");\n  }\n\n  return out;\n}\n\nfunction defaultValueFor(key: string): string {\n  switch (key) {\n    case \"A\":\n      return \"next\";\n    case \"W\":\n      return \"4\";\n    case \"L\":\n      return \"3600\";\n    case \"D\":\n      return \"\";\n    case \"I\":\n      return \"auto\";\n    case \"E\":\n      return \"state\";\n    case \"Z\":\n      return \"6\";\n    case \"T\":\n      return \"sec\";\n    case \"R\":\n      return \"auto\";\n    case \"M\":\n      return \"false\";\n    case \"N\":\n      return \"0\";\n    case \"WID\":\n    case \"KEY\":\n    case \"SIG\":\n    case \"DATA\":\n    case \"OUT\":\n    case \"MODE\":\n    case \"CODE\":\n      return \"\";\n    case \"DIGITS\":\n      return \"6\";\n    case \"MAX_AGE_SEC\":\n      return \"0\";\n    case \"MAX_FUTURE_SEC\":\n      return \"5\";\n    default:\n      return \"\";\n  }\n}\n\nfunction b64urlEncode(buf: Buffer): string {\n  return buf.toString(\"base64\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n}\n\nfunction b64urlDecode(s: string): Buffer {\n  let std = s.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const m = std.length % 4;\n  if (m === 2) std += \"==\";\n  else if (m === 3) std += \"=\";\n  else if (m === 1) throw new Error(\"invalid base64url signature length\");\n  return Buffer.from(std, \"base64\");\n}\n\nfunction buildSignVerifyMessage(c: Canon): Buffer {\n  const wid = c.WID ?? \"\";\n  if (!wid) throw new Error(\"WID=<wid_string> required\");\n  const parts: Buffer[] = [Buffer.from(wid, \"utf8\")];\n  if (c.DATA && c.DATA.length > 0) {\n    if (!existsSync(c.DATA)) throw new Error(`data file not found: ${c.DATA}`);\n    parts.push(readFileSync(c.DATA));\n  }\n  return Buffer.concat(parts);\n}\n\nfunction runSign(c: Canon): number {\n  const keyPath = c.KEY ?? \"\";\n  if (!keyPath) throw new Error(\"KEY=<private_key_path> required for A=sign\");\n  if (!existsSync(keyPath)) throw new Error(`private key file not found: ${keyPath}`);\n  const message = buildSignVerifyMessage(c);\n  const key = createPrivateKey(readFileSync(keyPath));\n  const sig = cryptoSign(null, message, key);\n  const out = b64urlEncode(sig);\n  if (c.OUT && c.OUT.length > 0) writeFileSync(c.OUT, out, \"utf8\");\n  else console.log(out);\n  return 0;\n}\n\nfunction runVerify(c: Canon): number {\n  const keyPath = c.KEY ?? \"\";\n  const sigText = c.SIG ?? \"\";\n  if (!keyPath) throw new Error(\"KEY=<public_key_path> required for A=verify\");\n  if (!sigText) throw new Error(\"SIG=<signature_string> required for A=verify\");\n  if (!existsSync(keyPath)) throw new Error(`public key file not found: ${keyPath}`);\n  const message = buildSignVerifyMessage(c);\n  const key = createPublicKey(readFileSync(keyPath));\n  const ok = cryptoVerify(null, message, key, b64urlDecode(sigText));\n  if (ok) {\n    console.log(\"Signature valid.\");\n    return 0;\n  }\n  console.error(\"Signature invalid.\");\n  return 1;\n}\n\nfunction resolveWOtpSecret(raw: string): string {\n  if (existsSync(raw)) return readFileSync(raw, \"utf8\").trim();\n  return raw.trim();\n}\n\nfunction computeWOtp(secret: string, wid: string, digits: number): string {\n  const digest = createHmac(\"sha256\", Buffer.from(secret, \"utf8\")).update(Buffer.from(wid, \"utf8\")).digest();\n  const binary = digest.readUInt32BE(0);\n  const mod = 10 ** digits;\n  return String(binary % mod).padStart(digits, \"0\");\n}\n\nfunction wotpWidTickMs(wid: string): number {\n  const m = /^(\\d{8})T(\\d{6})(\\d{3})?\\.[0-9]+Z/.exec(wid);\n  if (!m) throw new Error(\"WID timestamp is invalid for time-window verification\");\n  const date = m[1];\n  const hms = m[2];\n  const ms = m[3] ?? \"000\";\n  const y = Number(date.slice(0, 4));\n  const mo = Number(date.slice(4, 6));\n  const d = Number(date.slice(6, 8));\n  const hh = Number(hms.slice(0, 2));\n  const mm = Number(hms.slice(2, 4));\n  const ss = Number(hms.slice(4, 6));\n  const msec = Number(ms);\n  const tick = Date.UTC(y, mo - 1, d, hh, mm, ss, msec);\n  if (!Number.isFinite(tick)) throw new Error(\"WID timestamp is invalid for time-window verification\");\n  return tick;\n}\n\nfunction runWOtp(c: Canon): number {\n  const mode = (c.MODE ?? \"gen\").toLowerCase();\n  if (mode !== \"gen\" && mode !== \"verify\") throw new Error(\"MODE must be gen or verify for A=w-otp\");\n  if (!c.KEY || c.KEY.length === 0) throw new Error(\"KEY=<secret_or_path> required for A=w-otp\");\n  const secret = resolveWOtpSecret(c.KEY);\n  if (!secret) throw new Error(\"w-otp secret cannot be empty\");\n  const digits = c.DIGITS ?? 6;\n  if (!Number.isInteger(digits) || digits < 4 || digits > 10) throw new Error(\"DIGITS must be an integer between 4 and 10\");\n  const maxAgeSec = c.MAX_AGE_SEC ?? 0;\n  const maxFutureSec = c.MAX_FUTURE_SEC ?? 5;\n  if (!Number.isInteger(maxAgeSec) || maxAgeSec < 0) throw new Error(\"MAX_AGE_SEC must be a non-negative integer\");\n  if (!Number.isInteger(maxFutureSec) || maxFutureSec < 0) throw new Error(\"MAX_FUTURE_SEC must be a non-negative integer\");\n\n  let wid = c.WID ?? \"\";\n  if (!wid && mode === \"gen\") wid = new WidGen({ W: c.W, Z: c.Z, timeUnit: c.T }).next();\n  if (!wid) throw new Error(\"WID=<wid_string> required for A=w-otp MODE=verify\");\n\n  const otp = computeWOtp(secret, wid, digits);\n  if (mode === \"gen\") {\n    console.log(JSON.stringify({ wid, otp, digits }));\n    return 0;\n  }\n\n  const code = c.CODE ?? \"\";\n  if (!code) throw new Error(\"CODE=<otp_code> required for A=w-otp MODE=verify\");\n  if (maxAgeSec > 0 || maxFutureSec > 0) {\n    const widMs = wotpWidTickMs(wid);\n    const nowMs = Date.now();\n    const delta = nowMs - widMs;\n    if (delta < 0 && -delta > maxFutureSec * 1000) throw new Error(\"OTP invalid: WID timestamp is too far in the future\");\n    if (delta >= 0 && maxAgeSec > 0 && delta > maxAgeSec * 1000) throw new Error(\"OTP invalid: WID timestamp is too old\");\n  }\n  const got = Buffer.from(code, \"utf8\");\n  const exp = Buffer.from(otp, \"utf8\");\n  const ok = got.length === exp.length && timingSafeEqual(got, exp);\n  if (ok) {\n    console.log(\"OTP valid.\");\n    return 0;\n  }\n  console.error(\"OTP invalid.\");\n  return 1;\n}\n\nfunction parseStateAndTransport(c: Canon): { stateMode: string; transport: string } {\n  let stateMode = c.E;\n  let transport = c.R;\n  if (c.E.includes(\"+\")) {\n    const [left, right] = c.E.split(\"+\", 2);\n    stateMode = left;\n    if (transport === \"auto\") transport = right;\n  } else if (c.E.includes(\",\")) {\n    const [left, right] = c.E.split(\",\", 2);\n    stateMode = left;\n    if (transport === \"auto\") transport = right;\n  }\n  return { stateMode, transport };\n}\n\nfunction runtimeDir(): string {\n  return resolve(\".local/wid/typescript\");\n}\n\nfunction runtimePidFile(): string {\n  return resolve(runtimeDir(), \"service.pid\");\n}\n\nfunction runtimeLogFile(): string {\n  return resolve(runtimeDir(), \"service.log\");\n}\n\nfunction dataDir(c: Canon): string {\n  return c.D && c.D.length > 0 ? resolve(c.D) : resolve(\".local/services\");\n}\n\n/** Thin SQLite connection wrapper used by CLI helpers. */\ntype SqliteDb = {\n  exec: (sql: string) => void;\n  prepare: (sql: string) => { get: (...args: unknown[]) => unknown; run: (...args: unknown[]) => { changes?: number } };\n  close?: () => void;\n};\n\n/** Constructor signature for SQLite database handles. */\ntype SqliteCtor = new (path: string, options?: { timeout?: number }) => SqliteDb;\n\nfunction resolveNodeSqliteDatabaseSync(): SqliteCtor {\n  const proc = (globalThis as { process?: unknown }).process as\n    | { versions?: { node?: string }; getBuiltinModule?: (name: string) => unknown }\n    | undefined;\n  if (!proc?.versions?.node) throw new Error(\"SQLite requires Node.js\");\n  const builtin = typeof proc.getBuiltinModule === \"function\" ? proc.getBuiltinModule(\"node:sqlite\") : null;\n  if (builtin && typeof builtin === \"object\" && \"DatabaseSync\" in builtin) {\n    return (builtin as { DatabaseSync: SqliteCtor }).DatabaseSync;\n  }\n  throw new Error(\"node:sqlite unavailable in this Node runtime\");\n}\n\nfunction sqlStatePath(c: Canon): string {\n  return resolve(dataDir(c), \"wid_state.sqlite\");\n}\n\nfunction sqlStateKey(c: Canon): string {\n  return `wid:ts:${c.W}:${c.Z}:${c.T}`;\n}\n\nfunction sqlAllocateNextWid(c: Canon): string {\n  /** Node sqlite constructor used for state persistence. */\n  const DatabaseSync = resolveNodeSqliteDatabaseSync();\n  const db = new DatabaseSync(sqlStatePath(c), { timeout: 5000 });\n  try {\n    db.exec(\"PRAGMA journal_mode=WAL;\");\n    db.exec(\n      \"CREATE TABLE IF NOT EXISTS wid_state (k TEXT PRIMARY KEY, last_sec INTEGER NOT NULL, last_seq INTEGER NOT NULL)\"\n    );\n    const key = sqlStateKey(c);\n    db.prepare(\"INSERT OR IGNORE INTO wid_state(k,last_sec,last_seq) VALUES(?,0,-1)\").run(key);\n    const selectStmt = db.prepare(\"SELECT last_sec,last_seq FROM wid_state WHERE k=?\");\n    const casStmt = db.prepare(\"UPDATE wid_state SET last_sec=?,last_seq=? WHERE k=? AND last_sec=? AND last_seq=?\");\n\n    for (let i = 0; i < 256; i += 1) {\n      try {\n        const row = selectStmt.get(key) as { last_sec?: number; last_seq?: number } | undefined;\n        if (!row || typeof row.last_sec !== \"number\" || typeof row.last_seq !== \"number\") {\n          throw new Error(\"invalid SQL state row\");\n        }\n        const gen = new WidGen({ W: c.W, Z: c.Z, timeUnit: c.T });\n        gen.restoreState(row.last_sec, row.last_seq);\n        const id = gen.next();\n        const nextState = gen.state;\n        const updated = casStmt.run(nextState.lastSec, nextState.lastSeq, key, row.last_sec, row.last_seq);\n        if ((updated.changes ?? 0) === 1) return id;\n      } catch (e) {\n        const msg = (e as Error).message ?? \"\";\n        if (msg.includes(\"database is locked\")) continue;\n        throw e;\n      }\n    }\n    throw new Error(\"sql allocation contention: retry budget exhausted\");\n  } finally {\n    db.close?.();\n  }\n}\n\nfunction readPid(file: string): number | null {\n  try {\n    const value = readFileSync(file, \"utf-8\").trim();\n    if (!value) return null;\n    const pid = Number.parseInt(value, 10);\n    return Number.isNaN(pid) || pid <= 0 ? null : pid;\n  } catch {\n    return null;\n  }\n}\n\nfunction pidAlive(pid: number): boolean {\n  try {\n    process.kill(pid, 0);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction sleepSeconds(sec: number): void {\n  if (sec <= 0) return;\n  const i32 = new Int32Array(new SharedArrayBuffer(4));\n  Atomics.wait(i32, 0, 0, sec * 1000);\n}\n\nfunction runDiscover(): number {\n  console.log(\n    JSON.stringify({\n      impl: \"typescript\",\n      orchestration: \"native\",\n      actions: [\n        \"discover\",\n        \"scaffold\",\n        \"run\",\n        \"start\",\n        \"stop\",\n        \"status\",\n        \"logs\",\n        \"saf\",\n        \"saf-wid\",\n        \"wir\",\n        \"wism\",\n        \"wihp\",\n        \"wipr\",\n        \"duplex\",\n      ],\n      transports: [\"auto\", \"mqtt\", \"ws\", \"redis\", \"null\", \"stdout\"],\n    })\n  );\n  return 0;\n}\n\nfunction runScaffold(c: Canon): number {\n  if (!c.D || c.D.length === 0) throw new Error(\"D=<name> required for A=scaffold\");\n  const root = resolve(c.D);\n  mkdirSync(resolve(root, \"state\"), { recursive: true });\n  mkdirSync(resolve(root, \"logs\"), { recursive: true });\n  console.log(`scaffolded ${root}`);\n  return 0;\n}\n\nfunction runStatus(): number {\n  const pidFile = runtimePidFile();\n  const logFile = runtimeLogFile();\n  const pid = readPid(pidFile);\n  if (pid !== null && pidAlive(pid)) {\n    console.log(`wid-typescript status=running pid=${pid} log=${logFile}`);\n    return 0;\n  }\n  try {\n    unlinkSync(pidFile);\n  } catch {}\n  console.log(\"wid-typescript status=stopped\");\n  return 0;\n}\n\nfunction runLogs(): number {\n  const logFile = runtimeLogFile();\n  if (!existsSync(logFile)) {\n    console.log(\"wid-typescript logs: empty\");\n    return 0;\n  }\n  process.stdout.write(readFileSync(logFile, \"utf-8\"));\n  return 0;\n}\n\nfunction runStop(): number {\n  const pidFile = runtimePidFile();\n  const pid = readPid(pidFile);\n  if (pid === null || !pidAlive(pid)) {\n    try {\n      unlinkSync(pidFile);\n    } catch {}\n    console.log(\"wid-typescript stop: not running\");\n    return 0;\n  }\n  try {\n    process.kill(pid, \"SIGTERM\");\n  } catch (e) {\n    throw new Error(`failed to stop pid=${pid}: ${(e as Error).message}`);\n  }\n  try {\n    unlinkSync(pidFile);\n  } catch {}\n  console.log(`wid-typescript stop: stopped pid=${pid}`);\n  return 0;\n}\n\nfunction daemonCanonicalArgs(c: Canon, action: string): string[] {\n  return [\n    `A=${action}`,\n    `W=${c.W}`,\n    `L=${c.L}`,\n    `D=${c.D.length > 0 ? c.D : \"#\"}`,\n    `I=${c.I}`,\n    `E=${c.E}`,\n    `Z=${c.Z}`,\n    `T=${c.T}`,\n    `R=${c.R}`,\n    `M=${c.M ? \"true\" : \"false\"}`,\n    `N=${c.N}`,\n  ];\n}\n\nfunction runStart(c: Canon): number {\n  const dir = runtimeDir();\n  mkdirSync(dir, { recursive: true });\n  const pidFile = runtimePidFile();\n  const logFile = runtimeLogFile();\n\n  const existing = readPid(pidFile);\n  if (existing !== null && pidAlive(existing)) {\n    console.log(`wid-typescript start: already-running pid=${existing} log=${logFile}`);\n    return 0;\n  }\n\n  mkdirSync(dirname(logFile), { recursive: true });\n  const fd = openSync(logFile, \"a\");\n  const child = spawn(process.execPath, [process.argv[1]!, \"__daemon\", ...daemonCanonicalArgs(c, \"run\")], {\n    detached: true,\n    stdio: [\"ignore\", fd, fd],\n  });\n  closeSync(fd);\n  child.unref();\n  writeFileSync(pidFile, `${child.pid}\\n`, \"utf-8\");\n  console.log(`wid-typescript start: started pid=${child.pid} log=${logFile}`);\n  return 0;\n}\n\nfunction runServiceLoop(c: Canon, action: string): number {\n  const { stateMode, transport: rawTransport } = parseStateAndTransport(c);\n  let transport = rawTransport === \"auto\" ? \"mqtt\" : rawTransport;\n  if (\n    [\"saf-wid\", \"wir\", \"wism\", \"wihp\", \"wipr\", \"duplex\"].includes(action) &&\n    !LOCAL_SERVICE_TRANSPORTS.has(transport)\n  ) {\n    throw new Error(`invalid transport for A=${action}: ${transport}`);\n  }\n\n  const dir = dataDir(c);\n  mkdirSync(dir, { recursive: true });\n  const logLevel = process.env.LOG_LEVEL || \"INFO\";\n  const max = c.N <= 0 ? Number.POSITIVE_INFINITY : c.N;\n  const gen = new WidGen({ W: c.W, Z: c.Z, timeUnit: c.T });\n\n  let i = 0;\n  while (i < max) {\n    i += 1;\n    const wid = gen.next();\n    if (transport !== \"null\") {\n      if ([\"saf-wid\", \"wism\", \"wihp\", \"wipr\"].includes(action)) {\n        console.log(\n          JSON.stringify({\n            impl: \"typescript\",\n            action,\n            tick: i,\n            transport,\n            W: c.W,\n            Z: c.Z,\n            time_unit: c.T,\n            wid,\n            interval: c.L,\n            log_level: logLevel,\n            data_dir: dir,\n          })\n        );\n      } else if (action === \"duplex\") {\n        const bTransport = c.I !== \"auto\" && LOCAL_SERVICE_TRANSPORTS.has(c.I) ? c.I : \"ws\";\n        console.log(\n          JSON.stringify({\n            impl: \"typescript\",\n            action: \"duplex\",\n            tick: i,\n            a_transport: transport,\n            b_transport: bTransport,\n            interval: c.L,\n            data_dir: dir,\n          })\n        );\n      } else {\n        console.log(\n          JSON.stringify({\n            impl: \"typescript\",\n            action,\n            tick: i,\n            transport,\n            interval: c.L,\n            log_level: logLevel,\n            data_dir: dir,\n            state_mode: stateMode,\n          })\n        );\n      }\n    }\n    if (i < max && c.L > 0) sleepSeconds(c.L);\n  }\n  return 0;\n}\n\nfunction runNativeOrchestration(c: Canon): number {\n  switch (c.A) {\n    case \"discover\":\n      return runDiscover();\n    case \"scaffold\":\n      return runScaffold(c);\n    case \"run\":\n      return runServiceLoop(c, \"run\");\n    case \"start\":\n      return runStart(c);\n    case \"stop\":\n      return runStop();\n    case \"status\":\n      return runStatus();\n    case \"logs\":\n      return runLogs();\n    case \"saf\":\n      return runServiceLoop(c, \"saf\");\n    case \"saf-wid\":\n      return runServiceLoop(c, \"saf-wid\");\n    case \"wir\":\n      return runServiceLoop(c, \"wir\");\n    case \"wism\":\n      return runServiceLoop(c, \"wism\");\n    case \"wihp\":\n      return runServiceLoop(c, \"wihp\");\n    case \"wipr\":\n      return runServiceLoop(c, \"wipr\");\n    case \"duplex\":\n      return runServiceLoop(c, \"duplex\");\n    default:\n      throw new Error(`unknown A=${c.A}`);\n  }\n}\n\nfunction runCanonical(args: string[]): number {\n  const c = parseCanonical(args);\n  if (c.A === \"help-actions\") {\n    printActions();\n    return 0;\n  }\n\n  const { stateMode } = parseStateAndTransport(c);\n  const canonDataDir = dataDir(c);\n  mkdirSync(canonDataDir, { recursive: true });\n  const genOptions = { W: c.W, Z: c.Z, timeUnit: c.T } as const;\n\n  if (c.A === \"next\") {\n    if (stateMode === \"sql\") {\n      console.log(sqlAllocateNextWid(c));\n    } else {\n      console.log(new WidGen(genOptions).next());\n    }\n    return 0;\n  }\n\n  if (c.A === \"stream\") {\n    const gen = stateMode === \"sql\" ? null : new WidGen(genOptions);\n    const max = c.N <= 0 ? Number.POSITIVE_INFINITY : c.N;\n    let emitted = 0;\n    while (emitted < max) {\n      if (stateMode === \"sql\") {\n        console.log(sqlAllocateNextWid(c));\n      } else {\n        console.log(gen!.next());\n      }\n      emitted += 1;\n      if (emitted < max && c.L > 0) sleepSeconds(c.L);\n    }\n    return 0;\n  }\n\n  if (c.A === \"healthcheck\") {\n    runHealthcheck([\n      \"--kind\",\n      \"wid\",\n      \"--W\",\n      String(c.W),\n      \"--Z\",\n      String(c.Z),\n      \"--time-unit\",\n      c.T,\n      \"--json\",\n    ]);\n    return 0;\n  }\n\n  if (c.A === \"sign\") return runSign(c);\n  if (c.A === \"verify\") return runVerify(c);\n  if (c.A === \"w-otp\") return runWOtp(c);\n\n  return runNativeOrchestration(c);\n}\n\nfunction printCompletion(shell: string): void {\n  if (shell === \"bash\") {\n    process.stdout.write(\n      `_wid_complete() {\n  local cur=\"\\${COMP_WORDS[COMP_CWORD]}\"\n  local cmds=\"next stream healthcheck validate parse help-actions bench selftest completion\"\n  if [[ \"$cur\" == *=* ]]; then\n    local key=\"\\${cur%%=*}\" val=\"\\${cur#*=}\" vals=\"\"\n    case \"$key\" in\n      A) vals=\"next stream healthcheck sign verify w-otp discover scaffold run start stop status logs saf saf-wid wir wism wihp wipr duplex help-actions\" ;;\n      T) vals=\"sec ms\" ;;\n      I) vals=\"auto sh bash\" ;;\n      E) vals=\"state stateless sql\" ;;\n      R) vals=\"auto mqtt ws redis null stdout\" ;;\n      M) vals=\"true false\" ;;\n    esac\n    local IFS=$'\\\\n'\n    COMPREPLY=(\\$(for v in $vals; do [[ \"$v\" == \"$val\"* ]] && printf '%s\\\\n' \"\\${key}=\\${v}\"; done))\n  else\n    local kv=\"A= W= Z= T= N= L= D= I= E= R= M=\"\n    COMPREPLY=(\\$(compgen -W \"$cmds $kv\" -- \"$cur\"))\n  fi\n}\ncomplete -o nospace -F _wid_complete wid-ts\n`\n    );\n  } else if (shell === \"zsh\") {\n    process.stdout.write(\n      `#compdef wid-ts\n_wid_complete() {\n  local cur=\"\\${words[-1]}\"\n  local -a cmds=(next stream healthcheck validate parse help-actions bench selftest completion)\n  if [[ \"$cur\" == *=* ]]; then\n    local key=\"\\${cur%%=*}\"\n    local -a vals=()\n    case \"$key\" in\n      A) vals=(next stream healthcheck sign verify w-otp discover scaffold run start stop status logs saf saf-wid wir wism wihp wipr duplex help-actions) ;;\n      T) vals=(sec ms) ;;\n      I) vals=(auto sh bash) ;;\n      E) vals=(state stateless sql) ;;\n      R) vals=(auto mqtt ws redis null stdout) ;;\n      M) vals=(true false) ;;\n    esac\n    compadd -P \"\\${key}=\" -- \"\\${vals[@]}\"\n  else\n    compadd -- \"\\${cmds[@]}\" A= W= Z= T= N= L= D= I= E= R= M=\n  fi\n}\n_wid_complete \"$@\"\ncompdef _wid_complete wid-ts\n`\n    );\n  } else if (shell === \"fish\") {\n    process.stdout.write(\n      `complete -c wid-ts -e\ncomplete -c wid-ts -f -n 'not __fish_seen_subcommand_from next stream healthcheck validate parse help-actions bench selftest completion' -a next -d 'Emit one WID'\ncomplete -c wid-ts -f -n 'not __fish_seen_subcommand_from next stream healthcheck validate parse help-actions bench selftest completion' -a stream -d 'Stream WIDs continuously'\ncomplete -c wid-ts -f -n 'not __fish_seen_subcommand_from next stream healthcheck validate parse help-actions bench selftest completion' -a healthcheck -d 'Generate and validate a sample WID'\ncomplete -c wid-ts -f -n 'not __fish_seen_subcommand_from next stream healthcheck validate parse help-actions bench selftest completion' -a validate -d 'Validate a WID string'\ncomplete -c wid-ts -f -n 'not __fish_seen_subcommand_from next stream healthcheck validate parse help-actions bench selftest completion' -a parse -d 'Parse a WID string'\ncomplete -c wid-ts -f -n 'not __fish_seen_subcommand_from next stream healthcheck validate parse help-actions bench selftest completion' -a help-actions -d 'Show canonical action matrix'\ncomplete -c wid-ts -f -n 'not __fish_seen_subcommand_from next stream healthcheck validate parse help-actions bench selftest completion' -a completion -d 'Print shell completion script'\ncomplete -c wid-ts -f -a 'A=next A=stream A=healthcheck A=sign A=verify A=w-otp A=start A=stop A=status A=logs A=help-actions' -d 'Action'\ncomplete -c wid-ts -f -a 'T=sec T=ms' -d 'Time unit'\ncomplete -c wid-ts -f -a 'I=auto I=sh I=bash' -d 'Input source'\ncomplete -c wid-ts -f -a 'E=state E=stateless E=sql' -d 'State mode'\ncomplete -c wid-ts -f -a 'R=auto R=mqtt R=ws R=redis R=null R=stdout' -d 'Transport'\ncomplete -c wid-ts -f -a 'M=true M=false' -d 'Milliseconds mode'\ncomplete -c wid-ts -f -a 'W=' -d 'Sequence width'\ncomplete -c wid-ts -f -a 'Z=' -d 'Padding length'\ncomplete -c wid-ts -f -a 'N=' -d 'Count'\ncomplete -c wid-ts -f -a 'L=' -d 'Interval seconds'\n`\n    );\n  } else {\n    process.stderr.write(`error: unknown shell '${shell}'. Use: wid completion bash|zsh|fish\\n`);\n    process.exit(1);\n  }\n}\n\nfunction runSelftest(): number {\n  const wg = new WidGen({ W: 4, Z: 0, timeUnit: \"sec\" });\n  const a = wg.next();\n  const b = wg.next();\n  if (!(a < b)) return 1;\n  if (!validateWid(a, 4, 0, \"sec\")) return 1;\n\n  const hg = new HLCWidGen({ node: \"node01\", W: 4, Z: 0, timeUnit: \"sec\" });\n  const h = hg.next();\n  if (!validateHlcWid(h, 4, 0, \"sec\")) return 1;\n\n  if (validateWid(\"20260212T091530.0000Z-node01\", 4, 0, \"sec\")) return 1;\n  if (validateHlcWid(\"20260212T091530.0000Z\", 4, 0, \"sec\")) return 1;\n  if (!validateWid(\"20260212T091530123.0000Z\", 4, 0, \"ms\")) return 1;\n  if (!validateHlcWid(\"20260212T091530123.0000Z-node01\", 4, 0, \"ms\")) return 1;\n  return 0;\n}\n\nfunction main(): number {\n  const args = process.argv.slice(2);\n  if (args.length === 0) {\n    printHelp();\n    return 2;\n  }\n\n  if (args[0] === \"__daemon\") {\n    try {\n      return runCanonical(args.slice(1));\n    } catch (e) {\n      console.error(`error: ${(e as Error).message}`);\n      return 1;\n    }\n  }\n\n  if (args.some((a) => a.includes(\"=\"))) {\n    try {\n      return runCanonical(args);\n    } catch (e) {\n      console.error(`error: ${(e as Error).message}`);\n      return 1;\n    }\n  }\n\n  const [cmd, ...rest] = args;\n  if (cmd === \"help\" || cmd === \"-h\" || cmd === \"--help\") {\n    printHelp();\n    return 0;\n  }\n\n  if (cmd === \"help-actions\") {\n    printActions();\n    return 0;\n  }\n\n  if (cmd === \"selftest\") {\n    return runSelftest();\n  }\n\n  if (cmd === \"completion\") {\n    const shell = rest[0] ?? \"\";\n    if (!shell) {\n      process.stderr.write(\"usage: wid completion bash|zsh|fish\\n\");\n      return 1;\n    }\n    printCompletion(shell);\n    return 0;\n  }\n\n  try {\n    switch (cmd) {\n      case \"next\":\n        runNext(rest);\n        return 0;\n      case \"stream\":\n        runStream(rest);\n        return 0;\n      case \"validate\":\n        runValidate(rest);\n        return 0;\n      case \"parse\":\n        runParse(rest);\n        return 0;\n      case \"healthcheck\":\n        runHealthcheck(rest);\n        return 0;\n      case \"bench\":\n        runBench(rest);\n        return 0;\n      default:\n        throw new Error(`unknown command: ${cmd}`);\n    }\n  } catch (e) {\n    console.error(`error: ${(e as Error).message}`);\n    return 1;\n  }\n}\n\nprocess.exit(main());\n","/** Supported time-precision units for WID/HLC generators. */\nexport type TimeUnit = \"sec\" | \"ms\";\n\nexport function parseTimeUnit(input: string): TimeUnit {\n  if (input === \"sec\" || input === \"ms\") {\n    return input;\n  }\n  throw new Error(\"time-unit must be sec or ms\");\n}\n\nexport function timeDigits(unit: TimeUnit): number {\n  return unit === \"ms\" ? 9 : 6;\n}\n","/**\n * WID (Waldiez/SYNAPSE Identifier) generation and validation.\n * Format: YYYYMMDDTHHMMSS[mmm].<seqW>Z[-<scope>][-<padZ>]\n */\n\nimport { type TimeUnit, timeDigits } from \"./time\";\n\n/** Parsed WID components after a successful parse. */\nexport interface ParsedWid {\n  /** Raw identifier string that was parsed. */\n  raw: string;\n  /** UTC timestamp extracted from the WID envelope. */\n  timestamp: Date;\n  /** Sequential component embedded in the identifier. */\n  sequence: number;\n  /** Optional scope suffix if one was provided. */\n  scope: string | null;\n  /** Optional padding hex string when Z > 0. */\n  padding: string | null;\n}\n\n/** In-memory snapshot of the last seen second/sequence for a generator. */\nexport interface WidStateSnapshot {\n  lastSec: number;\n  lastSeq: number;\n}\n\n/** Storage contract consumed by `WidGen` when persistence is enabled. */\nexport interface WidStateStore {\n  load(key: string): WidStateSnapshot | null;\n  save(key: string, state: WidStateSnapshot): void;\n}\n\n/** Basic in-memory store that keeps Wid state during runtime. */\nexport class MemoryWidStateStore implements WidStateStore {\n  private readonly memory = new Map<string, WidStateSnapshot>();\n\n  load(key: string): WidStateSnapshot | null {\n    const hit = this.memory.get(key);\n    return hit ? { ...hit } : null;\n  }\n\n  save(key: string, state: WidStateSnapshot): void {\n    this.memory.set(key, { ...state });\n  }\n}\n\n/** Browser localStorage-backed store; falls back to no-op outside browsers. */\nclass BrowserLocalStorageWidStateStore implements WidStateStore {\n  private readonly prefix: string;\n\n  constructor(prefix = \"wid\") {\n    this.prefix = prefix;\n  }\n\n  private keyOf(key: string): string {\n    return `${this.prefix}:${key}`;\n  }\n\n  private localStorageLike():\n    | { getItem: (k: string) => string | null; setItem: (k: string, v: string) => void }\n    | null {\n    const g = globalThis as unknown as Record<string, unknown>;\n    const ls = g.localStorage as\n      | { getItem: (k: string) => string | null; setItem: (k: string, v: string) => void }\n      | undefined;\n    return ls ?? null;\n  }\n\n  load(key: string): WidStateSnapshot | null {\n    const ls = this.localStorageLike();\n    if (!ls) return null;\n    const raw = ls.getItem(this.keyOf(key));\n    if (!raw) return null;\n    try {\n      const parsed = JSON.parse(raw) as Partial<WidStateSnapshot>;\n      if (\n        typeof parsed.lastSec === \"number\" &&\n        Number.isFinite(parsed.lastSec) &&\n        typeof parsed.lastSeq === \"number\" &&\n        Number.isFinite(parsed.lastSeq)\n      ) {\n        return { lastSec: parsed.lastSec, lastSeq: parsed.lastSeq };\n      }\n    } catch {\n      return null;\n    }\n    return null;\n  }\n\n  save(key: string, state: WidStateSnapshot): void {\n    const ls = this.localStorageLike();\n    if (!ls) return;\n    ls.setItem(this.keyOf(key), JSON.stringify(state));\n  }\n}\n\n/**\n * Creates a browser localStorage-backed state store.\n * In non-browser runtimes this behaves as a no-op store.\n */\n/** Factory that wires the browser storage-backed Wid store for web runtimes. */\nexport function createBrowserWidStateStore(prefix = \"wid\"): WidStateStore {\n  return new BrowserLocalStorageWidStateStore(prefix);\n}\n\n/** SQLite-backed store for Node environments that support `node:sqlite`. */\nclass NodeSqliteWidStateStore implements WidStateStore {\n  private readonly db: {\n    exec: (sql: string) => void;\n    prepare: (sql: string) => { get: (...args: unknown[]) => unknown; run: (...args: unknown[]) => unknown };\n    close?: () => void;\n  };\n  private readonly prefix: string;\n\n  constructor(databasePath: string, prefix = \"wid\") {\n    this.prefix = prefix;\n    /** Node sqlite constructor used for CLI persistence. */\n    const DatabaseSync = resolveNodeSqliteDatabaseSync();\n    this.db = new DatabaseSync(databasePath);\n    this.db.exec(\n      \"CREATE TABLE IF NOT EXISTS wid_state (k TEXT PRIMARY KEY, last_sec INTEGER NOT NULL, last_seq INTEGER NOT NULL)\"\n    );\n  }\n\n  private fullKey(key: string): string {\n    return `${this.prefix}:${key}`;\n  }\n\n  load(key: string): WidStateSnapshot | null {\n    const row = this.db\n      .prepare(\"SELECT last_sec, last_seq FROM wid_state WHERE k = ?\")\n      .get(this.fullKey(key)) as { last_sec?: number; last_seq?: number } | undefined;\n    if (!row) return null;\n    if (typeof row.last_sec !== \"number\" || typeof row.last_seq !== \"number\") return null;\n    return { lastSec: row.last_sec, lastSeq: row.last_seq };\n  }\n\n  save(key: string, state: WidStateSnapshot): void {\n    this.db\n      .prepare(\n        \"INSERT INTO wid_state (k, last_sec, last_seq) VALUES (?, ?, ?) ON CONFLICT(k) DO UPDATE SET last_sec=excluded.last_sec, last_seq=excluded.last_seq\"\n      )\n      .run(this.fullKey(key), state.lastSec, state.lastSeq);\n  }\n\n  close(): void {\n    this.db.close?.();\n  }\n}\n\nfunction resolveNodeSqliteDatabaseSync(): new (path: string) => {\n  exec: (sql: string) => void;\n  prepare: (sql: string) => { get: (...args: unknown[]) => unknown; run: (...args: unknown[]) => unknown };\n  close?: () => void;\n} {\n  const proc = (globalThis as { process?: unknown }).process as\n    | { versions?: { node?: string }; getBuiltinModule?: (name: string) => unknown }\n    | undefined;\n  if (!proc?.versions?.node) {\n    throw new Error(\"SQLite state store requires Node.js\");\n  }\n\n  const builtin = typeof proc.getBuiltinModule === \"function\" ? proc.getBuiltinModule(\"node:sqlite\") : null;\n  if (builtin && typeof builtin === \"object\" && \"DatabaseSync\" in builtin) {\n    return (builtin as { DatabaseSync: new (path: string) => NodeSqliteWidStateStore[\"db\"] }).DatabaseSync;\n  }\n\n  throw new Error(\"node:sqlite unavailable in this Node runtime\");\n}\n\n/** Node factory that requires the `node:sqlite` module for persistence. */\nexport function createNodeSqliteWidStateStore(databasePath: string, prefix = \"wid\"): WidStateStore {\n  return new NodeSqliteWidStateStore(databasePath, prefix);\n}\n\n/** Configuration options accepted by `WidGen`. */\nexport interface WidGenOptions {\n  /** Width of the sequence segment (default 4). */\n  W?: number;\n  /** Padding length (default 6). */\n  Z?: number;\n  /** Optional scope suffix appended to generated IDs. */\n  scope?: string;\n  /** Time unit precision, either `sec` or `ms`. */\n  timeUnit?: TimeUnit;\n  /** Optional persistence layer for generator state. */\n  stateStore?: WidStateStore;\n  /** Key used when storing state. */\n  stateKey?: string;\n  /** Persist state after each generation when true. */\n  autoPersist?: boolean;\n}\n\n/** Extended configuration for streaming helpers around `WidGen`. */\nexport interface AsyncWidStreamOptions extends WidGenOptions {\n  /** Number of IDs to emit (0 for infinite). */\n  count?: number;\n  /** Delay between emits in milliseconds. */\n  intervalMs?: number;\n}\n\n/** Cache of regex instances for base WID formats per width/unit. */\nconst WID_BASE_RE_CACHE = new Map<string, RegExp>();\n/** Cache for padding-hex validation patterns keyed by width. */\nconst HEX_RE_CACHE = new Map<number, RegExp>();\n/** Scope suffix pattern accepted by all generators. */\nconst SCOPE_PATTERN = /^[A-Za-z0-9_]+(?:-[A-Za-z0-9_]+)*$/;\n\nfunction widBaseRe(W: number, unit: TimeUnit): RegExp {\n  const key = `${W}:${unit}`;\n  const cached = WID_BASE_RE_CACHE.get(key);\n  if (cached) return cached;\n  const re = new RegExp(`^(\\\\d{8})T(\\\\d{${timeDigits(unit)}})\\\\.(\\\\d{${W}})Z(.*)?$`);\n  WID_BASE_RE_CACHE.set(key, re);\n  return re;\n}\n\nfunction hexRe(Z: number): RegExp {\n  const cached = HEX_RE_CACHE.get(Z);\n  if (cached) return cached;\n  const re = new RegExp(`^[0-9a-f]{${Z}}$`);\n  HEX_RE_CACHE.set(Z, re);\n  return re;\n}\n\nfunction bytesToHex(bytes: Uint8Array): string {\n  return Array.from(bytes, (b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\nfunction randomHexChars(Z: number): string {\n  if (!globalThis.crypto?.getRandomValues) {\n    throw new Error(\"Secure random generator unavailable in this runtime\");\n  }\n  const bytes = new Uint8Array(Math.ceil(Z / 2));\n  globalThis.crypto.getRandomValues(bytes);\n  return bytesToHex(bytes).slice(0, Z);\n}\n\nfunction parseSuffix(\n  suffix: string,\n  Z: number\n): { scope: string | null; padding: string | null } | null {\n  if (!suffix) {\n    return { scope: null, padding: null };\n  }\n\n  if (!suffix.startsWith(\"-\")) {\n    return null;\n  }\n\n  const body = suffix.slice(1);\n  if (!body) {\n    return null;\n  }\n\n  let scope: string | null = null;\n  let padding: string | null = null;\n\n  if (Z > 0) {\n    const splitAt = body.lastIndexOf(\"-\");\n    if (splitAt >= 0) {\n      const maybeScope = body.slice(0, splitAt);\n      const maybePadding = body.slice(splitAt + 1);\n      if (hexRe(Z).test(maybePadding)) {\n        padding = maybePadding;\n        scope = maybeScope || null;\n      } else if (maybePadding.length === Z && /^[0-9A-Fa-f]+$/.test(maybePadding)) {\n        return null;\n      } else {\n        scope = body;\n      }\n    } else if (hexRe(Z).test(body)) {\n      padding = body;\n    } else if (body.length === Z && /^[0-9A-Fa-f]+$/.test(body)) {\n      return null;\n    } else {\n      scope = body;\n    }\n  } else {\n    scope = body;\n  }\n\n  if (scope !== null && !SCOPE_PATTERN.test(scope)) {\n    return null;\n  }\n\n  if (padding !== null && !hexRe(Z).test(padding)) {\n    return null;\n  }\n\n  return { scope, padding };\n}\n\nfunction parseTimestamp(dateStr: string, timeStr: string, timeUnit: TimeUnit): Date | null {\n  const year = parseInt(dateStr.slice(0, 4), 10);\n  const month = parseInt(dateStr.slice(4, 6), 10);\n  const day = parseInt(dateStr.slice(6, 8), 10);\n  const hour = parseInt(timeStr.slice(0, 2), 10);\n  const minute = parseInt(timeStr.slice(2, 4), 10);\n  const second = parseInt(timeStr.slice(4, 6), 10);\n  const millis = timeUnit === \"ms\" ? parseInt(timeStr.slice(6, 9), 10) : 0;\n\n  if (month < 1 || month > 12) return null;\n  if (day < 1 || day > 31) return null;\n  if (hour > 23 || minute > 59 || second > 59) return null;\n  if (millis < 0 || millis > 999) return null;\n\n  const timestamp = new Date(Date.UTC(year, month - 1, day, hour, minute, second, millis));\n  if (isNaN(timestamp.getTime())) return null;\n  if (timestamp.getUTCDate() !== day || timestamp.getUTCMonth() + 1 !== month) return null;\n  return timestamp;\n}\n\nfunction parseCore(wid: string, W: number, Z: number, timeUnit: TimeUnit): ParsedWid | null {\n  if (W <= 0 || Z < 0) return null;\n\n  const match = widBaseRe(W, timeUnit).exec(wid);\n  if (!match) return null;\n\n  const [, dateStr, timeStr, seqStr, suffixRaw] = match;\n  const suffix = suffixRaw ?? \"\";\n\n  const timestamp = parseTimestamp(dateStr, timeStr, timeUnit);\n  if (!timestamp) return null;\n\n  const parsedSuffix = parseSuffix(suffix, Z);\n  if (!parsedSuffix) return null;\n\n  return {\n    raw: wid,\n    timestamp,\n    sequence: parseInt(seqStr, 10),\n    scope: parsedSuffix.scope,\n    padding: parsedSuffix.padding,\n  };\n}\n\nexport function validateWid(wid: string, W = 4, Z = 6, timeUnit: TimeUnit = \"sec\"): boolean {\n  return parseCore(wid, W, Z, timeUnit) !== null;\n}\n\nexport function parseWid(wid: string, W = 4, Z = 6, timeUnit: TimeUnit = \"sec\"): ParsedWid | null {\n  return parseCore(wid, W, Z, timeUnit);\n}\n\nexport async function asyncNextWid(options: WidGenOptions = {}): Promise<string> {\n  return new WidGen(options).next();\n}\n\nexport async function* asyncWidStream(\n  options: AsyncWidStreamOptions = {}\n): AsyncGenerator<string> {\n  const { count = 0, intervalMs = 0, ...genOpts } = options;\n  if (count < 0) throw new Error(\"count must be >= 0\");\n  if (intervalMs < 0) throw new Error(\"intervalMs must be >= 0\");\n\n  const gen = new WidGen(genOpts);\n  let emitted = 0;\n  while (count === 0 || emitted < count) {\n    yield gen.next();\n    emitted += 1;\n    if (intervalMs > 0) {\n      await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    }\n  }\n}\n\n/** Stateful generator for WID IDs that keeps monotonicity guarantees. */\nexport class WidGen {\n  private readonly W: number;\n  private readonly Z: number;\n  private readonly scope: string | null;\n  private readonly timeUnit: TimeUnit;\n  private readonly maxSeq: number;\n  private readonly stateStore: WidStateStore | null;\n  private readonly stateKey: string;\n  private readonly autoPersist: boolean;\n\n  private lastSec = 0;\n  private lastSeq = -1;\n  private cachedSec = -1;\n  private cachedTs = \"\";\n\n  /** Create a generator with optional persistence and precision control. */\n  constructor(options: WidGenOptions = {}) {\n    const {\n      W = 4,\n      Z = 6,\n      scope,\n      timeUnit = \"sec\",\n      stateStore,\n      stateKey = \"wid\",\n      autoPersist = false,\n    } = options;\n\n    if (W <= 0) throw new Error(\"W must be > 0\");\n    if (Z < 0) throw new Error(\"Z must be >= 0\");\n    if (scope && !SCOPE_PATTERN.test(scope)) {\n      throw new Error(\"Invalid scope format\");\n    }\n\n    this.W = W;\n    this.Z = Z;\n    this.scope = scope ?? null;\n    this.timeUnit = timeUnit;\n    this.maxSeq = Math.pow(10, W) - 1;\n    this.stateStore = stateStore ?? null;\n    this.stateKey = stateKey;\n    this.autoPersist = autoPersist;\n\n    if (this.autoPersist && this.stateStore) {\n      const loaded = this.stateStore.load(this.stateKey);\n      if (\n        loaded &&\n        Number.isFinite(loaded.lastSec) &&\n        Number.isFinite(loaded.lastSeq) &&\n        loaded.lastSec >= 0 &&\n        loaded.lastSeq >= -1\n      ) {\n        this.lastSec = loaded.lastSec;\n        this.lastSeq = loaded.lastSeq;\n      }\n    }\n  }\n\n  private persistState(): void {\n    if (!this.autoPersist || !this.stateStore) return;\n    try {\n      this.stateStore.save(this.stateKey, { lastSec: this.lastSec, lastSeq: this.lastSeq });\n    } catch {\n      // Keep generator functional even if persistence fails.\n    }\n  }\n\n  private tsForTick(tick: number): string {\n    if (tick !== this.cachedSec) {\n      this.cachedSec = tick;\n      const sec = this.timeUnit === \"ms\" ? Math.floor(tick / 1000) : tick;\n      const ms = this.timeUnit === \"ms\" ? tick % 1000 : 0;\n      const d = new Date(sec * 1000);\n      const year = d.getUTCFullYear();\n      const month = String(d.getUTCMonth() + 1).padStart(2, \"0\");\n      const day = String(d.getUTCDate()).padStart(2, \"0\");\n      const hour = String(d.getUTCHours()).padStart(2, \"0\");\n      const minute = String(d.getUTCMinutes()).padStart(2, \"0\");\n      const second = String(d.getUTCSeconds()).padStart(2, \"0\");\n      const milli = String(ms).padStart(3, \"0\");\n      this.cachedTs =\n        this.timeUnit === \"ms\"\n          ? `${year}${month}${day}T${hour}${minute}${second}${milli}`\n          : `${year}${month}${day}T${hour}${minute}${second}`;\n    }\n    return this.cachedTs;\n  }\n\n  private nowTick(): number {\n    if (this.timeUnit === \"ms\") {\n      return Date.now();\n    }\n    return Math.floor(Date.now() / 1000);\n  }\n\n  next(): string {\n    const now = this.nowTick();\n    let tick = now > this.lastSec ? now : this.lastSec;\n    let seq = tick === this.lastSec ? this.lastSeq + 1 : 0;\n\n    if (seq > this.maxSeq) {\n      tick += 1;\n      seq = 0;\n    }\n\n    this.lastSec = tick;\n    this.lastSeq = seq;\n\n    const ts = this.tsForTick(tick);\n    const seqStr = String(seq).padStart(this.W, \"0\");\n    let wid = `${ts}.${seqStr}Z`;\n\n    if (this.scope) {\n      wid += `-${this.scope}`;\n    }\n\n    if (this.Z > 0) {\n      wid += `-${randomHexChars(this.Z)}`;\n    }\n\n    this.persistState();\n    return wid;\n  }\n\n  nextN(n: number): string[] {\n    return Array.from({ length: n }, () => this.next());\n  }\n\n  get state(): WidStateSnapshot {\n    return { lastSec: this.lastSec, lastSeq: this.lastSeq };\n  }\n\n  restoreState(lastSec: number, lastSeq: number): void {\n    this.lastSec = lastSec;\n    this.lastSeq = lastSeq;\n    this.persistState();\n  }\n}\n","/**\n * HLC-WID (Hybrid Logical Clock WID) generation, validation, and parsing.\n * Format: YYYYMMDDTHHMMSS[mmm].<lcW>Z-<node>[-<padZ>]\n */\n\nimport { type TimeUnit, timeDigits } from \"./time\";\n\n/** Parsed components of an HLC-WID after a successful parse. */\nexport interface ParsedHlcWid {\n  /** Raw HLC-WID string. */\n  raw: string;\n  /** UTC timestamp portion of the HLC-WID. */\n  timestamp: Date;\n  /** Logical clock counter embedded in the HLC-WID. */\n  logicalCounter: number;\n  /** Node identifier appended to the HLC-WID. */\n  node: string;\n  /** Optional padding when Z > 0. */\n  padding: string | null;\n}\n\n/** Minimal Hybrid Logical Clock state snapshot. */\nexport interface HLCState {\n  /** Physical timestamp used by the generator. */\n  pt: number;\n  /** Logical counter component. */\n  lc: number;\n}\n\n/** Configuration options for `HLCWidGen`. */\nexport interface HLCWidGenOptions {\n  /** Unique node identifier suffix. */\n  node: string;\n  /** Width of the logical counter (default 4). */\n  W?: number;\n  /** Optional padding length (default 0). */\n  Z?: number;\n  /** Time precision (defaults to `sec`). */\n  timeUnit?: TimeUnit;\n}\n\n/** Cache for HLC-WID regex instances per width/time unit pair. */\nconst HLC_BASE_RE_CACHE = new Map<string, RegExp>();\n/** Cache for hex validation patterns keyed by padding length. */\nconst HEX_RE_CACHE = new Map<number, RegExp>();\n/** Node identifier pattern reused by HLC generators. */\nconst NODE_RE = /^[A-Za-z0-9_]+$/;\n\nfunction hlcBaseRe(W: number, unit: TimeUnit): RegExp {\n  const key = `${W}:${unit}`;\n  const cached = HLC_BASE_RE_CACHE.get(key);\n  if (cached) return cached;\n  const re = new RegExp(`^(\\\\d{8})T(\\\\d{${timeDigits(unit)}})\\\\.(\\\\d{${W}})Z-([A-Za-z0-9_]+)(.*)$`);\n  HLC_BASE_RE_CACHE.set(key, re);\n  return re;\n}\n\nfunction hexRe(Z: number): RegExp {\n  const cached = HEX_RE_CACHE.get(Z);\n  if (cached) return cached;\n  const re = new RegExp(`^[0-9a-f]{${Z}}$`);\n  HEX_RE_CACHE.set(Z, re);\n  return re;\n}\n\nfunction randomHexChars(Z: number): string {\n  if (!globalThis.crypto?.getRandomValues) {\n    throw new Error(\"Secure random generator unavailable in this runtime\");\n  }\n  const bytes = new Uint8Array(Math.ceil(Z / 2));\n  globalThis.crypto.getRandomValues(bytes);\n  return Array.from(bytes, (b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\")\n    .slice(0, Z);\n}\n\nfunction isValidNode(node: string): boolean {\n  return NODE_RE.test(node);\n}\n\nfunction parseTimestamp(dateStr: string, timeStr: string, timeUnit: TimeUnit): Date | null {\n  const year = parseInt(dateStr.slice(0, 4), 10);\n  const month = parseInt(dateStr.slice(4, 6), 10);\n  const day = parseInt(dateStr.slice(6, 8), 10);\n  const hour = parseInt(timeStr.slice(0, 2), 10);\n  const minute = parseInt(timeStr.slice(2, 4), 10);\n  const second = parseInt(timeStr.slice(4, 6), 10);\n  const millis = timeUnit === \"ms\" ? parseInt(timeStr.slice(6, 9), 10) : 0;\n\n  if (month < 1 || month > 12) return null;\n  if (day < 1 || day > 31) return null;\n  if (hour > 23 || minute > 59 || second > 59) return null;\n  if (millis < 0 || millis > 999) return null;\n\n  const timestamp = new Date(Date.UTC(year, month - 1, day, hour, minute, second, millis));\n  if (isNaN(timestamp.getTime())) return null;\n  if (timestamp.getUTCDate() !== day || timestamp.getUTCMonth() + 1 !== month) return null;\n  return timestamp;\n}\n\nexport function validateHlcWid(\n  wid: string,\n  W = 4,\n  Z = 0,\n  timeUnit: TimeUnit = \"sec\"\n): boolean {\n  return parseHlcWid(wid, W, Z, timeUnit) !== null;\n}\n\nexport function parseHlcWid(\n  wid: string,\n  W = 4,\n  Z = 0,\n  timeUnit: TimeUnit = \"sec\"\n): ParsedHlcWid | null {\n  if (W <= 0 || Z < 0) return null;\n\n  const match = hlcBaseRe(W, timeUnit).exec(wid);\n  if (!match) return null;\n\n  const [, dateStr, timeStr, lcStr, node, suffixRaw] = match;\n  const suffix = suffixRaw ?? \"\";\n\n  if (!isValidNode(node)) return null;\n\n  const timestamp = parseTimestamp(dateStr, timeStr, timeUnit);\n  if (!timestamp) return null;\n\n  const logicalCounter = parseInt(lcStr, 10);\n\n  let padding: string | null = null;\n  if (suffix) {\n    if (!suffix.startsWith(\"-\")) return null;\n    const seg = suffix.slice(1);\n    if (Z === 0) return null;\n    if (!hexRe(Z).test(seg)) return null;\n    padding = seg;\n  }\n\n  return { raw: wid, timestamp, logicalCounter, node, padding };\n}\n\n/** Generator for HLC-WIDs that keeps the logical counter monotonic. */\nexport class HLCWidGen {\n  private readonly W: number;\n  private readonly Z: number;\n  private readonly node: string;\n  private readonly timeUnit: TimeUnit;\n  private readonly maxLC: number;\n  private pt = 0;\n  private lc = 0;\n  private cachedTick = -1;\n  private cachedTs = \"\";\n\n  constructor(options: HLCWidGenOptions) {\n    const { node, W = 4, Z = 0, timeUnit = \"sec\" } = options;\n    if (W <= 0) throw new Error(\"W must be > 0\");\n    if (Z < 0) throw new Error(\"Z must be >= 0\");\n    if (!isValidNode(node)) {\n      throw new Error(\"node must match [A-Za-z0-9_]+\");\n    }\n    this.W = W;\n    this.Z = Z;\n    this.node = node;\n    this.timeUnit = timeUnit;\n    this.maxLC = Math.pow(10, W) - 1;\n  }\n\n  private nowTick(): number {\n    if (this.timeUnit === \"ms\") {\n      return Date.now();\n    }\n    return Math.floor(Date.now() / 1000);\n  }\n\n  private tsForTick(tick: number): string {\n    if (tick !== this.cachedTick) {\n      this.cachedTick = tick;\n      const sec = this.timeUnit === \"ms\" ? Math.floor(tick / 1000) : tick;\n      const ms = this.timeUnit === \"ms\" ? tick % 1000 : 0;\n      const d = new Date(sec * 1000);\n      const year = d.getUTCFullYear();\n      const mo = String(d.getUTCMonth() + 1).padStart(2, \"0\");\n      const dy = String(d.getUTCDate()).padStart(2, \"0\");\n      const hr = String(d.getUTCHours()).padStart(2, \"0\");\n      const mi = String(d.getUTCMinutes()).padStart(2, \"0\");\n      const sc = String(d.getUTCSeconds()).padStart(2, \"0\");\n      const milli = String(ms).padStart(3, \"0\");\n      this.cachedTs =\n        this.timeUnit === \"ms\"\n          ? `${year}${mo}${dy}T${hr}${mi}${sc}${milli}`\n          : `${year}${mo}${dy}T${hr}${mi}${sc}`;\n    }\n    return this.cachedTs;\n  }\n\n  private rollover(): void {\n    if (this.lc > this.maxLC) {\n      this.pt += 1;\n      this.lc = 0;\n    }\n  }\n\n  observe(remotePT: number, remoteLC: number): void {\n    if (remotePT < 0 || remoteLC < 0) {\n      throw new Error(\"remote values must be non-negative\");\n    }\n    const now = this.nowTick();\n    const newPT = Math.max(now, this.pt, remotePT);\n\n    if (newPT === this.pt && newPT === remotePT) {\n      this.lc = Math.max(this.lc, remoteLC) + 1;\n    } else if (newPT === this.pt) {\n      this.lc += 1;\n    } else if (newPT === remotePT) {\n      this.lc = remoteLC + 1;\n    } else {\n      this.lc = 0;\n    }\n    this.pt = newPT;\n    this.rollover();\n  }\n\n  next(): string {\n    const now = this.nowTick();\n    if (now > this.pt) {\n      this.pt = now;\n      this.lc = 0;\n    } else {\n      this.lc += 1;\n    }\n    this.rollover();\n\n    const ts = this.tsForTick(this.pt);\n    const lcStr = String(this.lc).padStart(this.W, \"0\");\n    let wid = `${ts}.${lcStr}Z-${this.node}`;\n    if (this.Z > 0) {\n      wid += `-${randomHexChars(this.Z)}`;\n    }\n    return wid;\n  }\n\n  nextN(n: number): string[] {\n    return Array.from({ length: n }, () => this.next());\n  }\n\n  get state(): HLCState {\n    return { pt: this.pt, lc: this.lc };\n  }\n\n  restoreState(pt: number, lc: number): void {\n    if (pt < 0 || lc < 0) throw new Error(\"invalid state\");\n    this.pt = pt;\n    this.lc = lc;\n  }\n}\n\nexport async function asyncNextHlcWid(options: HLCWidGenOptions): Promise<string> {\n  return new HLCWidGen(options).next();\n}\n\nexport async function* asyncHlcWidStream(\n  options: HLCWidGenOptions & { count?: number; intervalMs?: number }\n): AsyncGenerator<string> {\n  const { count = 0, intervalMs = 0, ...genOpts } = options;\n  if (count < 0) throw new Error(\"count must be >= 0\");\n  if (intervalMs < 0) throw new Error(\"intervalMs must be >= 0\");\n  const gen = new HLCWidGen(genOpts);\n  let emitted = 0;\n  while (count === 0 || emitted < count) {\n    yield gen.next();\n    emitted++;\n    if (intervalMs > 0) {\n      await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    }\n  }\n}\n","/**\n * SYNAPSE Manifest-Based Binary Files.\n */\n\n/** Fixed header bytes used by SYNAPSE files. */\nexport const MANIFEST_MAGIC = new Uint8Array([0x53, 0x59, 0x4e, 0x4d]); // SYNM\n/** Current manifest version published in all files. */\nexport const MANIFEST_VERSION = 1;\n/** Maximum allowed manifest payload size in bytes. */\nexport const MAX_MANIFEST_SIZE = 64 * 1024;\n/** Length of the SYNAPSE file header (magic + version + length). */\nconst HEADER_SIZE = 10;\n\n/** Supported data media types stored inside a manifest. */\nexport enum DataType {\n  Unknown = 'unknown',\n  Text = 'text/plain',\n  Json = 'application/json',\n  Binary = 'application/octet-stream',\n}\n\n/** Shape of a manifest when decoding/encoding JSON representations. */\nexport interface ManifestData {\n  id: string;\n  version?: number;\n  node?: string;\n  data_type?: string;\n  data_size?: number;\n  data_hash?: string;\n  metadata?: Record<string, unknown>;\n}\n\nfunction concatBytes(parts: Uint8Array[]): Uint8Array {\n  const total = parts.reduce((acc, p) => acc + p.length, 0);\n  const out = new Uint8Array(total);\n  let offset = 0;\n  for (const p of parts) {\n    out.set(p, offset);\n    offset += p.length;\n  }\n  return out;\n}\n\nfunction equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction toHex(bytes: Uint8Array): string {\n  return Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');\n}\n\nasync function sha256Hex(data: Uint8Array): Promise<string> {\n  if (!globalThis.crypto?.subtle) {\n    throw new Error('Web Crypto API (crypto.subtle) is unavailable in this runtime');\n  }\n  // @ts-expect-error sth with Uint8Array\n  const digest = await globalThis.crypto.subtle.digest('SHA-256', data);\n  return toHex(new Uint8Array(digest));\n}\n\nfunction utf8Encode(s: string): Uint8Array {\n  return new TextEncoder().encode(s);\n}\n\nfunction utf8Decode(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Lightweight wrapper around manifest metadata with serialization helpers. */\nexport class Manifest {\n  id: string;\n  version: number;\n  node: string;\n  data_type: string;\n  data_size: number;\n  data_hash: string;\n  metadata: Record<string, unknown>;\n\n  constructor(data: ManifestData) {\n    this.id = data.id;\n    this.version = data.version ?? MANIFEST_VERSION;\n    this.node = data.node ?? '';\n    this.data_type = data.data_type ?? DataType.Unknown;\n    this.data_size = data.data_size ?? 0;\n    this.data_hash = data.data_hash ?? '';\n    this.metadata = data.metadata ?? {};\n  }\n\n  toJson(): string {\n    return JSON.stringify(this, null, 2);\n  }\n\n  toBytes(): Uint8Array {\n    return utf8Encode(this.toJson());\n  }\n\n  static fromJson(data: string): Manifest {\n    return new Manifest(JSON.parse(data));\n  }\n\n  static fromBytes(data: Uint8Array): Manifest {\n    return Manifest.fromJson(utf8Decode(data));\n  }\n}\n\n/** Composite object combining a manifest with its binary payload. */\nexport class SynapseFile {\n  manifest: Manifest;\n  payload: Uint8Array;\n\n  constructor(manifest: Manifest, payload: Uint8Array = new Uint8Array(0)) {\n    this.manifest = manifest;\n    this.payload = payload;\n  }\n\n  async toBytes(): Promise<Uint8Array> {\n    this.manifest.data_size = this.payload.length;\n    this.manifest.data_hash = await sha256Hex(this.payload);\n\n    const manifestBytes = this.manifest.toBytes();\n    if (manifestBytes.length > MAX_MANIFEST_SIZE) {\n      throw new Error(`Manifest too large: ${manifestBytes.length} bytes`);\n    }\n\n    const header = new Uint8Array(HEADER_SIZE);\n    header.set(MANIFEST_MAGIC, 0);\n    const view = new DataView(header.buffer, header.byteOffset, header.byteLength);\n    view.setUint16(4, MANIFEST_VERSION, false);\n    view.setUint32(6, manifestBytes.length, false);\n\n    return concatBytes([header, manifestBytes, this.payload]);\n  }\n\n  static fromBytes(data: Uint8Array): SynapseFile {\n    if (data.length < HEADER_SIZE) {\n      throw new Error('Data too small for SYNAPSE file');\n    }\n\n    const magic = data.subarray(0, 4);\n    if (!equalBytes(magic, MANIFEST_MAGIC)) {\n      throw new Error(`Invalid magic: ${utf8Decode(magic)}`);\n    }\n\n    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    const manifestSize = view.getUint32(6, false);\n    if (manifestSize > MAX_MANIFEST_SIZE) {\n      throw new Error(`Manifest too large: ${manifestSize} bytes`);\n    }\n\n    const manifestEnd = HEADER_SIZE + manifestSize;\n    const manifestBytes = data.subarray(HEADER_SIZE, manifestEnd);\n    const manifest = Manifest.fromBytes(manifestBytes);\n    const payload = data.subarray(manifestEnd);\n\n    return new SynapseFile(manifest, payload);\n  }\n\n  async verify(): Promise<boolean> {\n    const actualHash = await sha256Hex(this.payload);\n    return actualHash === this.manifest.data_hash;\n  }\n}\n"],"mappings":"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","names":["HEX_RE_CACHE","hexRe","randomHexChars","parseTimestamp","gen","parsed","cryptoSign","cryptoVerify"]}