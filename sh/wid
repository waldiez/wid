#!/usr/bin/env bash

set -euo pipefail

WID_DEFAULT_W=4
WID_DEFAULT_Z=6
HLC_DEFAULT_NODE="sh"
TIME_UNIT_DEFAULT="sec"

LAST_TICK=0
LAST_SEQ=-1
HLC_PT=0
HLC_LC=0
MS_TICK_MODE=""
MS_LAST_SEC=""
MS_LAST_SUB=-1
FMT_CACHE_TICK=""
FMT_CACHE_UNIT=""
FMT_CACHE_TS=""
WALL_EPOCH_BASE=""
WALL_SECONDS_BASE=0

wall_sec() {
    if [[ -z "$WALL_EPOCH_BASE" ]]; then
        WALL_EPOCH_BASE="$(date +%s)"
        WALL_SECONDS_BASE=$SECONDS
    fi
    printf '%s\n' "$((WALL_EPOCH_BASE + (SECONDS - WALL_SECONDS_BASE)))"
}

usage() {
    cat <<'USAGE'
wid - WID/HLC-WID generator CLI

Default:
  wid next

Usage:
  wid next [--kind wid|hlc] [--node <name>] [--W <n>] [--Z <n>] [--time-unit sec|ms]
  wid stream [--kind wid|hlc] [--node <name>] [--W <n>] [--Z <n>] [--count <n>] [--time-unit sec|ms]
  wid bench [--kind wid|hlc] [--node <name>] [--W <n>] [--Z <n>] [--count <n>] [--time-unit sec|ms]
  wid validate <id> [--kind wid|hlc] [--W <n>] [--Z <n>] [--time-unit sec|ms]
  wid healthcheck [--kind wid|hlc] [--node <name>] [--W <n>] [--Z <n>] [--time-unit sec|ms] [--json]
  wid selftest [--n <n>] [--procs <n>] [--per <n>] [--kind wid|hlc] [--W <n>] [--Z <n>]

Selftest notes:
  - Always runs a single-process test for wid(W=4,Z=0): validates, checks strict monotonicity, checks uniqueness.
  - Optional concurrency test (enabled with --procs):
      * kind=wid requires Z>0 (Z=0 is NOT unique across processes)
      * kind=hlc uses unique per-process nodes (works with Z=0)

Examples:
  wid selftest
  wid selftest --n 50000
  wid selftest --procs 6 --per 20000 --kind wid --W 4 --Z 6
  wid selftest --procs 6 --per 20000 --kind hlc --W 4 --Z 0

Canonical mode:
  wid W=# A=# L=# D=# I=# E=# Z=#

Optional:
  T=sec|ms
  R=auto|mqtt|ws|redis|http|tcp|udp|null|stdout
  N=<count>   # for A=stream, 0 means infinite
  MODE=gen|verify KEY=<secret_or_path> WID=<wid> CODE=<otp> DIGITS=4..10   # for A=w-otp
  MAX_AGE_SEC=<seconds> MAX_FUTURE_SEC=<seconds>                            # for A=w-otp MODE=verify
USAGE
}

print_actions() {
    cat <<'ACTIONS'
wid action matrix

Core ID:
  A=next | A=stream | A=healthcheck
  A=sign | A=verify | A=w-otp

Service lifecycle:
  A=discover | A=scaffold | A=run | A=start | A=stop | A=status | A=logs | A=heal | A=self.check-update

Local services:
  A=saf      (alias: raf)
  A=saf-wid  (aliases: waf, wraf)
  A=wir      (alias: witr)
  A=wism     (alias: wim)
  A=wihp     (alias: wih)
  A=wipr     (alias: wip)
  A=duplex

Transport adapters:
  R=auto|mqtt|ws|redis|http|tcp|udp|null|stdout
  ws   -> websocat (if available)
  http -> curl (if available)
  tcp/udp -> nc (if available)

Help:
  A=help-actions
ACTIONS
}

die() {
    printf 'error: %s\n' "$1" >&2
    exit 1
}

is_int() {
    [[ "${1:-}" =~ ^-?[0-9]+$ ]]
}

now_tick() {
    local time_unit=$1
    if [[ "$time_unit" == "ms" ]]; then
        local out sec ns

        if [[ -z "$MS_TICK_MODE" ]]; then
            out="$(date +%s%3N 2>/dev/null || true)"
            if [[ "$out" =~ ^[0-9]+$ ]]; then
                MS_TICK_MODE="date_ms"
            else
                out="$(date +%s%N 2>/dev/null || true)"
                if [[ "$out" =~ ^[0-9]+$ ]]; then
                    MS_TICK_MODE="date_ns"
                else
                    MS_TICK_MODE="sec_counter"
                fi
            fi
        fi

        case "$MS_TICK_MODE" in
        date_ms)
            date +%s%3N
            ;;
        date_ns)
            ns="$(date +%s%N)"
            printf '%s\n' "$((ns / 1000000))"
            ;;
        sec_counter)
            sec="$(wall_sec)"
            if [[ "$sec" == "$MS_LAST_SEC" ]]; then
                MS_LAST_SUB=$((MS_LAST_SUB + 1))
                if ((MS_LAST_SUB > 999)); then
                    MS_LAST_SUB=999
                fi
            else
                MS_LAST_SEC="$sec"
                MS_LAST_SUB=0
            fi
            printf '%s%03d\n' "$sec" "$MS_LAST_SUB"
            ;;
        *)
            printf '%s000\n' "$(wall_sec)"
            ;;
        esac
    else
        wall_sec
    fi
}

# Cross-platform epoch->UTC timestamp:
# - BSD/macOS: date -r <sec>
# - GNU coreutils: date -d "@<sec>"
# - BusyBox: supports -d "@<sec>" on most distros
fmt_ts() {
    local tick=$1
    local time_unit=$2
    local sec_part ms_part base

    if [[ "$tick" == "$FMT_CACHE_TICK" && "$time_unit" == "$FMT_CACHE_UNIT" ]]; then
        printf '%s\n' "$FMT_CACHE_TS"
        return 0
    fi

    if [[ "$time_unit" == "ms" ]]; then
        sec_part=$((tick / 1000))
        ms_part=$((tick % 1000))
    else
        sec_part=$tick
        ms_part=0
    fi

    if date -u -r 0 +%Y%m%dT%H%M%S >/dev/null 2>&1; then
        base="$(date -u -r "$sec_part" +%Y%m%dT%H%M%S)"
    else
        base="$(date -u -d "@$sec_part" +%Y%m%dT%H%M%S)"
    fi

    if [[ "$time_unit" == "ms" ]]; then
        FMT_CACHE_TS="$(printf '%s%03d' "$base" "$ms_part")"
    else
        FMT_CACHE_TS="$base"
    fi
    FMT_CACHE_TICK="$tick"
    FMT_CACHE_UNIT="$time_unit"
    printf '%s\n' "$FMT_CACHE_TS"
}

is_leap_year() {
    local y=$1
    ((y % 400 == 0)) && return 0
    ((y % 100 == 0)) && return 1
    ((y % 4 == 0)) && return 0
    return 1
}

valid_ymdhms() {
    local year=$1 month=$2 day=$3 hour=$4 minute=$5 second=$6
    local y m d hh mm ss dim

    y=$((10#$year))
    m=$((10#$month))
    d=$((10#$day))
    hh=$((10#$hour))
    mm=$((10#$minute))
    ss=$((10#$second))

    ((m < 1 || m > 12)) && return 1
    ((hh < 0 || hh > 23)) && return 1
    ((mm < 0 || mm > 59)) && return 1
    ((ss < 0 || ss > 59)) && return 1

    case "$m" in
    1 | 3 | 5 | 7 | 8 | 10 | 12) dim=31 ;;
    4 | 6 | 9 | 11) dim=30 ;;
    2)
        dim=28
        if is_leap_year "$y"; then dim=29; fi
        ;;
    *) return 1 ;;
    esac

    ((d >= 1 && d <= dim))
}

# Node rules:
# - non-empty
# - no whitespace
# - must NOT contain '-' (to avoid ambiguity with -<pad>)
valid_node() {
    local node=$1
    [[ -n "$node" ]] || return 1
    [[ "$node" != *[[:space:]]* ]] || return 1
    [[ "$node" != *-* ]] || return 1
    return 0
}

rand_hex() {
    local z=$1
    if ((z <= 0)); then
        printf ''
        return 0
    fi

    local need=$(((z + 1) / 2))
    local raw
    if command -v openssl >/dev/null 2>&1; then
        raw=$(openssl rand -hex "$need")
    else
        raw=$(LC_ALL=C od -An -N "$need" -tx1 /dev/urandom | tr -d ' \n')
    fi
    printf '%s' "${raw:0:z}"
}

validate_wid() {
    local id=$1 W=$2 Z=$3 time_unit=${4:-sec}
    [[ $W =~ ^[1-9][0-9]*$ ]] || return 1
    [[ $Z =~ ^[0-9]+$ ]] || return 1

    [[ "$time_unit" == "sec" || "$time_unit" == "ms" ]] || return 1

    local re ts seq suffix
    local time_digits=6
    [[ "$time_unit" == "ms" ]] && time_digits=9
    re="^([0-9]{8}T[0-9]{$time_digits})\\.([0-9]{$W})Z(.*)$"
    [[ "$id" =~ $re ]] || return 1
    ts=${BASH_REMATCH[1]}
    seq=${BASH_REMATCH[2]}
    suffix=${BASH_REMATCH[3]}

    local year=${ts:0:4} month=${ts:4:2} day=${ts:6:2}
    local hour=${ts:9:2} minute=${ts:11:2} second=${ts:13:2}
    local millis=0
    if [[ "$time_unit" == "ms" ]]; then
        millis=$((10#${ts:15:3}))
        ((millis >= 0 && millis <= 999)) || return 1
    fi
    valid_ymdhms "$year" "$month" "$day" "$hour" "$minute" "$second" || return 1

    if ((Z == 0)); then
        [[ -z "$suffix" ]] || return 1
        return 0
    fi

    [[ "$suffix" =~ ^-[0-9a-f]{$Z}$ ]] || return 1
    return 0
}

validate_hlc_wid() {
    local id=$1 W=$2 Z=$3 time_unit=${4:-sec}
    [[ $W =~ ^[1-9][0-9]*$ ]] || return 1
    [[ $Z =~ ^[0-9]+$ ]] || return 1

    [[ "$time_unit" == "sec" || "$time_unit" == "ms" ]] || return 1

    local re ts node suffix
    local time_digits=6
    [[ "$time_unit" == "ms" ]] && time_digits=9
    re="^([0-9]{8}T[0-9]{$time_digits})\\.([0-9]{$W})Z-([^-[:space:]]+)(.*)$"
    [[ "$id" =~ $re ]] || return 1
    ts=${BASH_REMATCH[1]}
    node=${BASH_REMATCH[3]}
    suffix=${BASH_REMATCH[4]}

    local year=${ts:0:4} month=${ts:4:2} day=${ts:6:2}
    local hour=${ts:9:2} minute=${ts:11:2} second=${ts:13:2}
    local millis=0
    if [[ "$time_unit" == "ms" ]]; then
        millis=$((10#${ts:15:3}))
        ((millis >= 0 && millis <= 999)) || return 1
    fi
    valid_ymdhms "$year" "$month" "$day" "$hour" "$minute" "$second" || return 1
    valid_node "$node" || return 1

    if ((Z == 0)); then
        [[ -z "$suffix" ]] || return 1
        return 0
    fi

    [[ "$suffix" =~ ^-[0-9a-f]{$Z}$ ]] || return 1
    return 0
}

parse_wid_fn() {
    local id=$1 W=$2 Z=$3 time_unit=$4 json=$5
    local re ts seq suffix time_digits=6
    [[ "$time_unit" == "ms" ]] && time_digits=9
    re="^([0-9]{8}T[0-9]{${time_digits}})\\.([0-9]{${W}})Z(.*)$"
    [[ "$id" =~ $re ]] || { printf 'null\n'; return 1; }
    ts=${BASH_REMATCH[1]}
    seq=${BASH_REMATCH[2]}
    suffix=${BASH_REMATCH[3]}
    local pad=""
    if ((Z > 0)); then
        [[ "$suffix" =~ ^-[0-9a-f]{${Z}}$ ]] || { printf 'null\n'; return 1; }
        pad="${suffix:1}"
    else
        [[ -z "$suffix" ]] || { printf 'null\n'; return 1; }
    fi
    local year=${ts:0:4} month=${ts:4:2} day=${ts:6:2}
    local hour=${ts:9:2} minute=${ts:11:2} second=${ts:13:2}
    local timestamp="${year}-${month}-${day}T${hour}:${minute}:${second}+00:00"
    local seq_int=$((10#$seq))
    if $json; then
        local pad_json="null"
        [[ -n "$pad" ]] && pad_json="\"${pad}\""
        printf '{"raw":"%s","timestamp":"%s","sequence":%d,"padding":%s}\n' \
            "$(json_escape "$id")" "$timestamp" "$seq_int" "$pad_json"
    else
        printf 'raw=%s\ntimestamp=%s\nsequence=%d\npadding=%s\n' \
            "$id" "$timestamp" "$seq_int" "$pad"
    fi
}

parse_hlc_wid_fn() {
    local id=$1 W=$2 Z=$3 time_unit=$4 json=$5
    local re ts lc node suffix time_digits=6
    [[ "$time_unit" == "ms" ]] && time_digits=9
    re="^([0-9]{8}T[0-9]{${time_digits}})\\.([0-9]{${W}})Z-([^-[:space:]]+)(.*)$"
    [[ "$id" =~ $re ]] || { printf 'null\n'; return 1; }
    ts=${BASH_REMATCH[1]}
    lc=${BASH_REMATCH[2]}
    node=${BASH_REMATCH[3]}
    suffix=${BASH_REMATCH[4]}
    local pad=""
    if ((Z > 0)); then
        [[ "$suffix" =~ ^-[0-9a-f]{${Z}}$ ]] || { printf 'null\n'; return 1; }
        pad="${suffix:1}"
    else
        [[ -z "$suffix" ]] || { printf 'null\n'; return 1; }
    fi
    local year=${ts:0:4} month=${ts:4:2} day=${ts:6:2}
    local hour=${ts:9:2} minute=${ts:11:2} second=${ts:13:2}
    local timestamp="${year}-${month}-${day}T${hour}:${minute}:${second}+00:00"
    local lc_int=$((10#$lc))
    if $json; then
        local pad_json="null"
        [[ -n "$pad" ]] && pad_json="\"${pad}\""
        printf '{"raw":"%s","timestamp":"%s","logical_counter":%d,"node":"%s","padding":%s}\n' \
            "$(json_escape "$id")" "$timestamp" "$lc_int" "$(json_escape "$node")" "$pad_json"
    else
        printf 'raw=%s\ntimestamp=%s\nlogical_counter=%d\nnode=%s\npadding=%s\n' \
            "$id" "$timestamp" "$lc_int" "$node" "$pad"
    fi
}

wotp_wid_tick_ms() {
    local id=$1
    local re ts millis year month day hour minute second sec
    re='^([0-9]{8}T[0-9]{6}([0-9]{3})?)\.[0-9]+Z.*$'
    [[ "$id" =~ $re ]] || return 1
    ts=${BASH_REMATCH[1]}
    millis=${BASH_REMATCH[2]:-000}
    [[ "$millis" =~ ^[0-9]{3}$ ]] || return 1

    year=${ts:0:4}
    month=${ts:4:2}
    day=${ts:6:2}
    hour=${ts:9:2}
    minute=${ts:11:2}
    second=${ts:13:2}

    valid_ymdhms "$year" "$month" "$day" "$hour" "$minute" "$second" || return 1

    if date -u -j -f "%Y%m%dT%H%M%S" "${year}${month}${day}T${hour}${minute}${second}" +%s >/dev/null 2>&1; then
        sec="$(date -u -j -f "%Y%m%dT%H%M%S" "${year}${month}${day}T${hour}${minute}${second}" +%s)"
    else
        sec="$(date -u -d "${year}-${month}-${day} ${hour}:${minute}:${second}" +%s 2>/dev/null)" || return 1
    fi

    printf '%s\n' "$((sec * 1000 + 10#$millis))"
}

wid_next_into() {
    # Usage: wid_next_into <varname> <W> <Z> <time_unit>
    local __out=$1 W=$2 Z=$3 time_unit=$4
    local max_seq=$((10 ** W - 1))
    local now tick seq ts seq_str pad id

    now=$(now_tick "$time_unit")

    if ((now > LAST_TICK)); then
        tick=$now
        seq=0
    else
        tick=$LAST_TICK
        seq=$((LAST_SEQ + 1))
    fi

    if ((seq > max_seq)); then
        tick=$((tick + 1))
        seq=0
    fi

    LAST_TICK=$tick
    LAST_SEQ=$seq

    ts=$(fmt_ts "$tick" "$time_unit")
    printf -v seq_str "%0${W}d" "$seq"

    if ((Z > 0)); then
        pad=$(rand_hex "$Z")
        id="${ts}.${seq_str}Z-${pad}"
    else
        id="${ts}.${seq_str}Z"
    fi

    printf -v "$__out" '%s' "$id"
}
wid_next() {
    local W=$1 Z=$2 time_unit=$3 out
    wid_next_into out "$W" "$Z" "$time_unit"
    printf '%s\n' "$out"
}

hlc_next() {
    local node=$1 W=$2 Z=$3 time_unit=$4
    local max_lc=$((10 ** W - 1))
    local now ts lc_str pad

    now=$(now_tick "$time_unit")
    if ((now > HLC_PT)); then
        HLC_PT=$now
        HLC_LC=0
    else
        HLC_LC=$((HLC_LC + 1))
    fi

    if ((HLC_LC > max_lc)); then
        HLC_PT=$((HLC_PT + 1))
        HLC_LC=0
    fi

    ts=$(fmt_ts "$HLC_PT" "$time_unit")
    printf -v lc_str "%0${W}d" "$HLC_LC"

    if ((Z > 0)); then
        pad=$(rand_hex "$Z")
        printf '%s.%sZ-%s-%s\n' "$ts" "$lc_str" "$node" "$pad"
    else
        printf '%s.%sZ-%s\n' "$ts" "$lc_str" "$node"
    fi
}

# Minimal JSON escaping for sample IDs (quotes + backslash are enough for our IDs)
json_escape() {
    local s=$1
    s=${s//\\/\\\\}
    s=${s//\"/\\\"}
    printf '%s' "$s"
}

is_true() {
    local raw="${1:-}"
    local norm
    norm="$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]')"
    case "$norm" in
    1 | true | yes | y | on) return 0 ;;
    *) return 1 ;;
    esac
}

is_transport() {
    case "${1:-}" in
    mqtt | ws | redis | http | tcp | udp | null | stdout | auto) return 0 ;;
    *) return 1 ;;
    esac
}

is_interval() {
    [[ "${1:-}" =~ ^[0-9]+$ ]]
}

repo_root() {
    cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd
}

run_canonical() {
    local ROOT_DIR
    ROOT_DIR="$(repo_root)"

    local A="run" W="4" L="3600" D="" I="auto" E="state" Z="6" T="sec" R="auto" M="false" N="0"
    local WID="" KEY="" SIG="" DATA="" OUT="" MODE="" CODE="" DIGITS="6" MAX_AGE_SEC="0" MAX_FUTURE_SEC="5"
    local L_FROM_PLACEHOLDER="false"
    local arg key val

    for arg in "$@"; do
        if [[ "$arg" == "-h" || "$arg" == "--help" || "$arg" == "help" ]]; then
            usage
            exit 0
        fi
        [[ "$arg" == *=* ]] || die "expected KEY=VALUE, got '$arg'"
        key="${arg%%=*}"
        val="${arg#*=}"
        case "$key" in
        A) A="$val" ;;
        W) W="$val" ;;
        L)
            L="$val"
            [[ "$val" == "#" ]] && L_FROM_PLACEHOLDER="true"
            ;;
        D) D="$val" ;;
        I) I="$val" ;;
        E) E="$val" ;;
        Z) Z="$val" ;;
        T) T="$val" ;;
        R) R="$val" ;;
        M) M="$val" ;;
        N) N="$val" ;;
        WID) WID="$val" ;;
        KEY) KEY="$val" ;;
        SIG) SIG="$val" ;;
        DATA) DATA="$val" ;;
        OUT) OUT="$val" ;;
        MODE) MODE="$val" ;;
        CODE) CODE="$val" ;;
        DIGITS) DIGITS="$val" ;;
        MAX_AGE_SEC) MAX_AGE_SEC="$val" ;;
        MAX_FUTURE_SEC) MAX_FUTURE_SEC="$val" ;;
        *) die "unknown key: $key" ;;
        esac
    done

    # Treat "#" as placeholder ("use default"), useful for Make invocations.
    [[ "$A" == "#" ]] && A="next"
    [[ "$W" == "#" ]] && W="4"
    [[ "$L" == "#" ]] && L="3600"
    [[ "$D" == "#" ]] && D=""
    [[ "$I" == "#" ]] && I="auto"
    [[ "$E" == "#" ]] && E="state"
    [[ "$Z" == "#" ]] && Z="6"
    [[ "$T" == "#" ]] && T="sec"
    [[ "$R" == "#" ]] && R="auto"
    [[ "$M" == "#" ]] && M="false"
    [[ "$N" == "#" ]] && N="0"
    [[ "$MODE" == "#" ]] && MODE=""
    [[ "$CODE" == "#" ]] && CODE=""
    [[ "$DIGITS" == "#" ]] && DIGITS="6"
    [[ "$MAX_AGE_SEC" == "#" ]] && MAX_AGE_SEC="0"
    [[ "$MAX_FUTURE_SEC" == "#" ]] && MAX_FUTURE_SEC="5"

    # For stream, placeholder L should be interactive-friendly.
    if [[ "$A" == "stream" && "$L_FROM_PLACEHOLDER" == "true" ]]; then
        L="1"
    fi

    A="$(printf '%s' "$A" | tr '[:upper:]' '[:lower:]')"

    if is_true "$M"; then
        T="ms"
    fi

    # Action aliases
    case "$A" in
    raf) A="saf" ;;
    waf | wraf) A="saf-wid" ;;
    witr) A="wir" ;;
    wim) A="wism" ;;
    wih) A="wihp" ;;
    wip) A="wipr" ;;
    esac

    if [[ "$A" == "help-actions" ]]; then
        print_actions
        return
    fi

    sign_verify_message_file() {
        local msg_file="$1"
        printf '%s' "$WID" >"$msg_file"
        if [[ -n "$DATA" ]]; then
            [[ -f "$DATA" ]] || die "data file not found: $DATA"
            cat "$DATA" >>"$msg_file"
        fi
    }

    b64url_encode_file() {
        local in_file="$1"
        openssl base64 -A <"$in_file" | tr '+/' '-_' | tr -d '='
    }

    b64url_decode_to_file() {
        local sig_url="$1" out_file="$2"
        local std bpad
        std="$(printf '%s' "$sig_url" | tr '_-' '/+')"
        bpad=$(( ${#std} % 4 ))
        if [[ $bpad -eq 2 ]]; then
            std="${std}=="
        elif [[ $bpad -eq 3 ]]; then
            std="${std}="
        elif [[ $bpad -eq 1 ]]; then
            die "invalid base64url signature length"
        fi
        printf '%s' "$std" | openssl base64 -A -d >"$out_file" 2>/dev/null || die "invalid signature encoding"
    }

    if [[ "$A" == "sign" ]]; then
        [[ -n "$WID" ]] || die "WID=<wid_string> required for A=sign"
        [[ -n "$KEY" ]] || die "KEY=<private_key_path> required for A=sign"
        [[ -f "$KEY" ]] || die "private key file not found: $KEY"
        command -v openssl >/dev/null 2>&1 || die "openssl is required for A=sign"
        local msg_file sig_file sig_out
        msg_file="$(mktemp)"
        sig_file="$(mktemp)"
        sign_verify_message_file "$msg_file"
        openssl pkeyutl -sign -inkey "$KEY" -rawin -in "$msg_file" -out "$sig_file" >/dev/null 2>&1 || {
            rm -f "$msg_file" "$sig_file"
            die "sign failed (ensure Ed25519 private key PEM)"
        }
        sig_out="$(b64url_encode_file "$sig_file")"
        rm -f "$msg_file" "$sig_file"
        if [[ -n "$OUT" ]]; then
            printf '%s' "$sig_out" >"$OUT"
        else
            printf '%s\n' "$sig_out"
        fi
        return
    fi

    if [[ "$A" == "verify" ]]; then
        [[ -n "$WID" ]] || die "WID=<wid_string> required for A=verify"
        [[ -n "$KEY" ]] || die "KEY=<public_key_path> required for A=verify"
        [[ -n "$SIG" ]] || die "SIG=<signature_string> required for A=verify"
        [[ -f "$KEY" ]] || die "public key file not found: $KEY"
        command -v openssl >/dev/null 2>&1 || die "openssl is required for A=verify"
        local msg_file sig_file
        msg_file="$(mktemp)"
        sig_file="$(mktemp)"
        sign_verify_message_file "$msg_file"
        b64url_decode_to_file "$SIG" "$sig_file"
        if openssl pkeyutl -verify -pubin -inkey "$KEY" -sigfile "$sig_file" -rawin -in "$msg_file" >/dev/null 2>&1; then
            rm -f "$msg_file" "$sig_file"
            echo "Signature valid."
            return
        fi
        rm -f "$msg_file" "$sig_file"
        echo "Signature invalid." >&2
        exit 1
    fi

    wotp_secret() {
        local raw="$1"
        if [[ -f "$raw" ]]; then
            tr -d '\r\n' <"$raw"
        else
            printf '%s' "$raw"
        fi
    }

    wotp_code() {
        local secret="$1" wid="$2" digits="$3"
        command -v openssl >/dev/null 2>&1 || die "openssl is required for A=w-otp"
        local hex first num mod i
        hex="$(printf '%s' "$wid" | openssl dgst -sha256 -mac HMAC -macopt "key:$secret" 2>/dev/null | awk '{print $NF}')"
        [[ "$hex" =~ ^[0-9a-fA-F]{64}$ ]] || die "failed to compute w-otp digest"
        first="${hex:0:8}"
        num=$((16#$first))
        mod=1
        for ((i = 0; i < digits; i++)); do
            mod=$((mod * 10))
        done
        printf "%0${digits}d" "$((num % mod))"
    }

    if [[ "$A" == "w-otp" ]]; then
        local mode secret otp
        mode="$(printf '%s' "${MODE:-gen}" | tr '[:upper:]' '[:lower:]')"
        [[ "$mode" == "gen" || "$mode" == "verify" ]] || die "MODE must be gen or verify for A=w-otp"
        [[ "$DIGITS" =~ ^[0-9]+$ ]] || die "DIGITS must be an integer"
        ((DIGITS >= 4 && DIGITS <= 10)) || die "DIGITS must be between 4 and 10"
        [[ "$MAX_AGE_SEC" =~ ^[0-9]+$ ]] || die "MAX_AGE_SEC must be a non-negative integer"
        [[ "$MAX_FUTURE_SEC" =~ ^[0-9]+$ ]] || die "MAX_FUTURE_SEC must be a non-negative integer"
        [[ -n "$KEY" ]] || die "KEY=<secret_or_path> required for A=w-otp"
        secret="$(wotp_secret "$KEY")"
        [[ -n "$secret" ]] || die "w-otp secret cannot be empty"

        if [[ -z "$WID" && "$mode" == "gen" ]]; then
            WID="$(wid_next "$W" "$Z" "$T")"
        fi
        [[ -n "$WID" ]] || die "WID=<wid_string> required for A=w-otp MODE=verify"

        otp="$(wotp_code "$secret" "$WID" "$DIGITS")"
        if [[ "$mode" == "gen" ]]; then
            printf '{"wid":"%s","otp":"%s","digits":%s}\n' "$(json_escape "$WID")" "$otp" "$DIGITS"
            return
        fi
        [[ -n "$CODE" ]] || die "CODE=<otp_code> required for A=w-otp MODE=verify"
        if ((MAX_AGE_SEC > 0 || MAX_FUTURE_SEC > 0)); then
            local wid_ms now_ms delta_ms
            wid_ms="$(wotp_wid_tick_ms "$WID")" || die "WID timestamp is invalid for time-window verification"
            now_ms="$(now_tick ms)"
            delta_ms=$((now_ms - wid_ms))
            if ((delta_ms < 0)); then
                ((-delta_ms <= MAX_FUTURE_SEC * 1000)) || die "OTP invalid: WID timestamp is too far in the future"
            elif ((MAX_AGE_SEC > 0)); then
                ((delta_ms <= MAX_AGE_SEC * 1000)) || die "OTP invalid: WID timestamp is too old"
            fi
        fi
        if [[ "$CODE" == "$otp" ]]; then
            echo "OTP valid."
            return
        fi
        echo "OTP invalid." >&2
        exit 1
    fi

    [[ "$T" == "sec" || "$T" == "ms" ]] || die "T must be sec or ms"
    [[ "$N" =~ ^[0-9]+$ ]] || die "N must be a non-negative integer"
    is_interval "$L" || die "L must be a non-negative integer (seconds)"

    run_python_wid_cli() {
        local impl_dir="$ROOT_DIR/python"
        local py_cmd=""
        [[ -d "$impl_dir/wid" ]] || die "python implementation not found: $impl_dir"

        for cand in python3.14 python3.13 python3.12 python3.11 python3.10 python3; do
            if command -v "$cand" >/dev/null 2>&1; then
                if "$cand" -c 'import sys; raise SystemExit(0 if sys.version_info >= (3, 10) else 1)' >/dev/null 2>&1; then
                    py_cmd="$cand"
                    break
                fi
            fi
        done

        if [[ -n "$py_cmd" ]]; then
            (cd "$impl_dir" && PYTHONPATH="$impl_dir${PYTHONPATH:+:$PYTHONPATH}" "$py_cmd" -m wid "$@")
            return 0
        fi
        if command -v uv >/dev/null 2>&1; then
            if (cd "$impl_dir" && uv run python -m wid "$@"); then
                return 0
            fi
        else
            die "python runtime not found (need uv or python>=3.10)"
        fi
    }

    local id_impl="$I"
    if [[ "$id_impl" == "auto" ]]; then
        if [[ -d "$ROOT_DIR/python/wid" ]] && (command -v uv >/dev/null 2>&1 || command -v python3 >/dev/null 2>&1); then
            id_impl="py"
        else
            id_impl="sh"
        fi
    fi

    local state_mode="$E"
    local effective_transport="$R"
    if [[ "$E" == *"+"* ]]; then
        state_mode="${E%%+*}"
        [[ "$effective_transport" == "auto" ]] && effective_transport="${E#*+}"
    elif [[ "$E" == *","* ]]; then
        state_mode="${E%%,*}"
        [[ "$effective_transport" == "auto" ]] && effective_transport="${E#*,}"
    fi
    case "$state_mode" in
    state | stateless | sql) ;;
    *) die "E must be state|stateless|sql (optionally +transport)" ;;
    esac

    local data_dir
    if [[ -n "$D" ]]; then
        data_dir="$D"
    else
        data_dir="$ROOT_DIR/.local/services"
    fi
    mkdir -p "$data_dir"

    sql_escape() {
        printf '%s' "$1" | sed "s/'/''/g"
    }

    sql_allocate_next_wid() {
        command -v sqlite3 >/dev/null 2>&1 || die "sqlite3 is required for E=sql"
        local db="$data_dir/wid_state.sqlite"
        local key
        key="$(sql_escape "wid:sh:${W}:${Z}:${T}")"
        mkdir -p "$data_dir"
        sqlite3 -cmd ".timeout 5000" "$db" \
            "CREATE TABLE IF NOT EXISTS wid_state (k TEXT PRIMARY KEY, last_tick INTEGER NOT NULL, last_seq INTEGER NOT NULL);INSERT OR IGNORE INTO wid_state(k,last_tick,last_seq) VALUES('$key',0,-1);" >/dev/null

        local row old_tick old_seq next_id new_tick new_seq changed
        for _ in $(seq 1 64); do
            row="$(sqlite3 -cmd ".timeout 5000" "$db" "SELECT last_tick || '|' || last_seq FROM wid_state WHERE k='$key';" | tr -d '\r')"
            [[ -n "$row" && "$row" == *"|"* ]] || die "invalid SQL state row"
            old_tick="${row%%|*}"
            old_seq="${row##*|}"
            [[ "$old_tick" =~ ^-?[0-9]+$ && "$old_seq" =~ ^-?[0-9]+$ ]] || die "invalid SQL state values"

            LAST_TICK="$old_tick"
            LAST_SEQ="$old_seq"
            wid_next_into next_id "$W" "$Z" "$T"
            new_tick="$LAST_TICK"
            new_seq="$LAST_SEQ"
            changed="$(sqlite3 -cmd ".timeout 5000" "$db" "UPDATE wid_state SET last_tick=$new_tick,last_seq=$new_seq WHERE k='$key' AND last_tick=$old_tick AND last_seq=$old_seq;SELECT changes();" | tail -n1 | tr -d '\r')"
            if [[ "$changed" == "1" ]]; then
                printf '%s\n' "$next_id"
                return 0
            fi
        done
        die "sql allocation contention: retry budget exhausted"
    }

    case "$A" in
    next)
        if [[ "$state_mode" == "sql" ]]; then
            sql_allocate_next_wid
        elif [[ "$id_impl" == "py" ]]; then
            run_python_wid_cli next --kind wid --W "$W" --Z "$Z" --time-unit "$T"
        else
            wid_next "$W" "$Z" "$T"
        fi
        return
        ;;
    stream)
        if [[ "$state_mode" == "sql" ]]; then
            if ((N > 0)); then
                local i
                for ((i = 0; i < N; i++)); do
                    sql_allocate_next_wid
                    if ((i + 1 < N)); then
                        sleep "$L"
                    fi
                done
            else
                while true; do
                    sql_allocate_next_wid
                    sleep "$L"
                done
            fi
        elif [[ "$id_impl" == "py" ]]; then
            run_python_wid_cli stream --kind wid --W "$W" --Z "$Z" --time-unit "$T" --count "$N" --interval-ms "$((L * 1000))"
        else
            if ((N > 0)); then
                local i
                for ((i = 0; i < N; i++)); do
                    wid_next "$W" "$Z" "$T"
                    if ((i + 1 < N)); then
                        sleep "$L"
                    fi
                done
            else
                while true; do
                    wid_next "$W" "$Z" "$T"
                    sleep "$L"
                done
            fi
        fi
        return
        ;;
    healthcheck)
        if [[ "$id_impl" == "py" ]]; then
            run_python_wid_cli healthcheck --kind wid --W "$W" --Z "$Z" --time-unit "$T" --json
        else
            local sample ok=true
            sample="$(wid_next "$W" "$Z" "$T")"
            validate_wid "$sample" "$W" "$Z" "$T" || ok=false
            printf '{"ok":%s,"kind":"wid","W":%s,"Z":%s,"time_unit":"%s","sample_id":"%s"}\n' \
                "$ok" "$W" "$Z" "$T" "$(json_escape "$sample")"
            $ok || exit 1
        fi
        return
        ;;
    esac

    local mode_args=()
    if [[ "$state_mode" == "stateless" ]]; then
        mode_args+=(--stateless)
    else
        mode_args+=(--with-state)
    fi

    local log_level="${LOG_LEVEL:-INFO}"
    local runtime_dir="$ROOT_DIR/.local/wid/sh"
    local pid_file="$runtime_dir/service.pid"
    local log_file="$runtime_dir/service.log"
    mkdir -p "$runtime_dir"

    transport_send() {
        local transport="$1" payload="$2"
        local t
        t="$(printf '%s' "$transport" | tr '[:upper:]' '[:lower:]')"
        [[ "$t" == "auto" ]] && t="stdout"

        case "$t" in
        stdout)
            printf '%s\n' "$payload"
            ;;
        null)
            :
            ;;
        ws)
            if command -v websocat >/dev/null 2>&1; then
                local ws_url="${WID_WS_URL:-ws://127.0.0.1:8787}"
                printf '%s\n' "$payload" | websocat -n - "$ws_url" >/dev/null 2>&1 || true
            else
                printf '%s\n' "$payload"
            fi
            ;;
        http)
            if command -v curl >/dev/null 2>&1; then
                local http_url="${WID_HTTP_URL:-http://127.0.0.1:8080/wid}"
                curl -fsS --max-time 2 -H 'content-type: application/json' -d "$payload" "$http_url" >/dev/null 2>&1 || true
            else
                printf '%s\n' "$payload"
            fi
            ;;
        tcp | udp)
            if command -v nc >/dev/null 2>&1; then
                local addr host port proto
                if [[ "$t" == "tcp" ]]; then
                    addr="${WID_TCP_ADDR:-127.0.0.1:9000}"
                    proto=""
                else
                    addr="${WID_UDP_ADDR:-127.0.0.1:9001}"
                    proto="-u"
                fi
                host="${addr%:*}"
                port="${addr##*:}"
                if [[ -n "$host" && -n "$port" && "$port" =~ ^[0-9]+$ ]]; then
                    # shellcheck disable=SC2086
                    printf '%s\n' "$payload" | nc $proto -w 1 "$host" "$port" >/dev/null 2>&1 || true
                else
                    printf '%s\n' "$payload"
                fi
            else
                printf '%s\n' "$payload"
            fi
            ;;
        mqtt)
            if command -v mosquitto_pub >/dev/null 2>&1; then
                local topic="${WID_MQTT_TOPIC:-wid/events}"
                local host="${WID_MQTT_HOST:-127.0.0.1}"
                local port="${WID_MQTT_PORT:-1883}"
                mosquitto_pub -h "$host" -p "$port" -t "$topic" -m "$payload" >/dev/null 2>&1 || true
            else
                printf '%s\n' "$payload"
            fi
            ;;
        redis)
            if command -v redis-cli >/dev/null 2>&1; then
                local channel="${WID_REDIS_CHANNEL:-wid:events}"
                redis-cli PUBLISH "$channel" "$payload" >/dev/null 2>&1 || true
            else
                printf '%s\n' "$payload"
            fi
            ;;
        *)
            die "invalid transport: $transport"
            ;;
        esac
    }

    service_loop_native() {
        local action="$1" a_transport="$2" b_transport="$3"
        local loops="$N"
        [[ "$loops" =~ ^[0-9]+$ ]] || loops=0
        ((loops <= 0)) && loops=10

        local i id payload
        for ((i = 1; i <= loops; i++)); do
            if [[ "$id_impl" == "py" ]]; then
                id="$(run_python_wid_cli next --kind wid --W "$W" --Z "$Z" --time-unit "$T")"
            else
                id="$(wid_next "$W" "$Z" "$T")"
            fi

            case "$action" in
            run)
                printf '%s\n' "$id"
                ;;
            duplex)
                payload=$(printf '{"impl":"sh","action":"duplex","tick":%d,"id":"%s","a_transport":"%s","b_transport":"%s","interval":%s,"data_dir":"%s"}' \
                    "$i" "$(json_escape "$id")" "$a_transport" "$b_transport" "$L" "$(json_escape "$data_dir")")
                transport_send "$a_transport" "$payload"
                transport_send "$b_transport" "$payload"
                ;;
            *)
                payload=$(printf '{"impl":"sh","action":"%s","tick":%d,"id":"%s","transport":"%s","interval":%s,"data_dir":"%s","log_level":"%s"}' \
                    "$action" "$i" "$(json_escape "$id")" "$a_transport" "$L" "$(json_escape "$data_dir")" "$log_level")
                transport_send "$a_transport" "$payload"
                ;;
            esac

            if ((i < loops)); then
                sleep "$L"
            fi
        done
    }

    start_native() {
        local daemon_args=("__daemon" "A=run" "W=$W" "L=$L" "D=$D" "I=$I" "E=$E" "Z=$Z" "T=$T" "R=$R" "M=$M" "N=$N")
        nohup "$0" "${daemon_args[@]}" >"$log_file" 2>&1 &
        echo "$!" >"$pid_file"
        printf 'started sh service pid=%s\n' "$!"
    }

    stop_native() {
        if [[ -f "$pid_file" ]]; then
            local pid
            pid="$(cat "$pid_file" 2>/dev/null || true)"
            if [[ -n "$pid" ]]; then
                kill "$pid" 2>/dev/null || true
                return 0
            fi
            rm -f "$pid_file"
            echo "stopped"
        else
            echo "not-running"
        fi
    }

    status_native() {
        if [[ -f "$pid_file" ]]; then
            local pid
            pid="$(cat "$pid_file" 2>/dev/null || true)"
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                echo "running"
            else
                echo "stale"
            fi
        else
            echo "stopped"
        fi
    }

    logs_native() {
        if [[ -f "$log_file" ]]; then
            tail -n 40 "$log_file"
        else
            echo "no-log"
        fi
    }

    heal_native() {
        local created_dirs=0 stale_pid_removed=0 active_pid_kept=0
        local tic_to_toc=0 toc_to_tic=0 stale_data_pids_removed=0
        local run_pid_file="$ROOT_DIR/.local/wid/run.pid"
        local pid

        if [[ ! -d "$runtime_dir" ]]; then
            mkdir -p "$runtime_dir"
            created_dirs=$((created_dirs + 1))
        fi
        if [[ ! -d "$data_dir" ]]; then
            mkdir -p "$data_dir"
            created_dirs=$((created_dirs + 1))
        fi

        if [[ -f "$pid_file" ]]; then
            pid="$(cat "$pid_file" 2>/dev/null || true)"
            if [[ -z "$pid" || ! "$pid" =~ ^[0-9]+$ ]] || ! kill -0 "$pid" 2>/dev/null; then
                rm -f "$pid_file"
                stale_pid_removed=$((stale_pid_removed + 1))
            else
                active_pid_kept=$((active_pid_kept + 1))
            fi
        fi

        if [[ -f "$run_pid_file" ]]; then
            pid="$(cat "$run_pid_file" 2>/dev/null || true)"
            if [[ -z "$pid" || ! "$pid" =~ ^[0-9]+$ ]] || ! kill -0 "$pid" 2>/dev/null; then
                rm -f "$run_pid_file"
                stale_pid_removed=$((stale_pid_removed + 1))
            else
                active_pid_kept=$((active_pid_kept + 1))
            fi
        fi

        while IFS= read -r -d '' tic_path; do
            local toc_path
            toc_path="${tic_path%.tic}.toc"
            if [[ ! -f "$toc_path" ]]; then
                cp "$tic_path" "$toc_path" 2>/dev/null || true
                [[ -f "$toc_path" ]] && tic_to_toc=$((tic_to_toc + 1))
            fi
        done < <(find "$data_dir" -type f -name '*.tic' -print0 2>/dev/null)

        while IFS= read -r -d '' toc_path; do
            local tic_path
            tic_path="${toc_path%.toc}.tic"
            if [[ ! -f "$tic_path" ]]; then
                cp "$toc_path" "$tic_path" 2>/dev/null || true
                [[ -f "$tic_path" ]] && toc_to_tic=$((toc_to_tic + 1))
            fi
        done < <(find "$data_dir" -type f -name '*.toc' -print0 2>/dev/null)

        while IFS= read -r -d '' data_pid_file; do
            local data_pid
            data_pid="$(cat "$data_pid_file" 2>/dev/null || true)"
            if [[ -z "$data_pid" || ! "$data_pid" =~ ^[0-9]+$ ]] || ! kill -0 "$data_pid" 2>/dev/null; then
                rm -f "$data_pid_file"
                stale_data_pids_removed=$((stale_data_pids_removed + 1))
            fi
        done < <(find "$data_dir" -type f -name '*.pid' -print0 2>/dev/null)

        printf '{"ok":true,"action":"heal","impl":"sh","runtime_dir":"%s","data_dir":"%s","created_dirs":%d,"stale_pid_removed":%d,"active_pid_kept":%d,"tic_to_toc":%d,"toc_to_tic":%d,"stale_data_pids_removed":%d}\n' \
            "$(json_escape "$runtime_dir")" "$(json_escape "$data_dir")" \
            "$created_dirs" "$stale_pid_removed" "$active_pid_kept" "$tic_to_toc" "$toc_to_tic" "$stale_data_pids_removed"
    }

    check_update_native() {
        local current="1.0.0"
        local latest=""
        local update_exists=false

        if command -v curl >/dev/null 2>&1; then
            # Check GitHub for latest release tag
            latest=$(curl -fsSL --max-time 3 https://api.github.com/repos/waldiez/wid/releases/latest 2>/dev/null | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' | sed 's/^v//')
            if [[ -n "$latest" && "$latest" != "$current" ]]; then
                update_exists=true
            fi
        fi

        printf '{"current":"%s","latest":"%s","update_exists":%s}\n' "$current" "${latest:-$current}" "$update_exists"
    }

    case "$A" in
    discover)
        printf '{"impl":"sh","orchestration":"native","actions":["discover","scaffold","run","start","stop","status","logs","heal","saf","saf-wid","wir","wism","wihp","wipr","duplex","self.check-update"],"transports":["auto","mqtt","ws","redis","http","tcp","udp","null","stdout"]}\n'
        ;;
    scaffold)
        [[ -n "$D" ]] || die "D=<name> required for A=scaffold"
        mkdir -p "$D/state" "$D/logs"
        printf 'scaffolded %s\n' "$D"
        ;;
    run)
        service_loop_native "run" "$effective_transport" "$I"
        ;;
    start)
        start_native
        ;;
    stop) stop_native ;;
    status) status_native ;;
    logs) logs_native ;;
    heal) heal_native ;;
    self.check-update) check_update_native ;;
    saf)
        [[ "$effective_transport" == "auto" ]] && effective_transport="stdout"
        is_transport "$effective_transport" || die "invalid transport for A=saf: $effective_transport"
        service_loop_native "saf" "$effective_transport" "$I"
        ;;
    saf-wid)
        [[ "$effective_transport" == "auto" ]] && effective_transport="mqtt"
        is_transport "$effective_transport" || die "invalid transport for A=saf-wid: $effective_transport"
        service_loop_native "saf-wid" "$effective_transport" "$I"
        ;;
    wir)
        [[ "$effective_transport" == "auto" ]] && effective_transport="mqtt"
        is_transport "$effective_transport" || die "invalid transport: $effective_transport"
        service_loop_native "wir" "$effective_transport" "$I"
        ;;
    wism)
        [[ "$effective_transport" == "auto" ]] && effective_transport="mqtt"
        is_transport "$effective_transport" || die "invalid transport for A=wism: $effective_transport"
        service_loop_native "wism" "$effective_transport" "$I"
        ;;
    wihp)
        [[ "$effective_transport" == "auto" ]] && effective_transport="mqtt"
        is_transport "$effective_transport" || die "invalid transport for A=wihp: $effective_transport"
        service_loop_native "wihp" "$effective_transport" "$I"
        ;;
    wipr)
        [[ "$effective_transport" == "auto" ]] && effective_transport="mqtt"
        is_transport "$effective_transport" || die "invalid transport for A=wipr: $effective_transport"
        service_loop_native "wipr" "$effective_transport" "$I"
        ;;
    duplex)
        local a_transport="$effective_transport"
        local b_transport="ws"
        [[ "$a_transport" == "auto" ]] && a_transport="mqtt"
        if is_transport "$I" && [[ "$I" != "auto" ]]; then b_transport="$I"; fi
        is_transport "$a_transport" || die "invalid side-A transport: $a_transport"
        is_transport "$b_transport" || die "invalid side-B transport: $b_transport"
        service_loop_native "duplex" "$a_transport" "$b_transport"
        ;;
    *) die "unknown A=$A" ;;
    esac
}
run_selftest() {
    local n=$1 procs=$2 per=$3 kind=$4 W=$5 Z=$6 time_unit=$7

    # Keep the original lightweight checks
    local a b h two
    two=$(for _ in 1 2; do wid_next 4 0 "$time_unit"; done)
    a=$(printf '%s\n' "$two" | sed -n '1p')
    b=$(printf '%s\n' "$two" | sed -n '2p')
    [[ "$a" < "$b" ]] || return 1
    validate_wid "$a" 4 0 "$time_unit" || return 1

    h=$(hlc_next node01 4 0 "$time_unit")
    validate_hlc_wid "$h" 4 0 "$time_unit" || return 1

    validate_wid "20260212T091530.0000Z-node01" 4 0 "$time_unit" && return 1
    validate_hlc_wid "20260212T091530.0000Z" 4 0 "$time_unit" && return 1

    # ------------------------------------------------------------
    # Fast single-process test (O(n)):
    # wid(W=4,Z=0) validate + strict monotonicity.
    # Strict monotonicity implies uniqueness, so no need to sort/uniq.
    # ------------------------------------------------------------
    local prev="" cur
    for ((i=0;i<n;i++)); do
        wid_next_into cur 4 0 "$time_unit"
        validate_wid "$cur" 4 0 "$time_unit" || return 1

        if [[ -n "$prev" ]] && [[ ! "$cur" > "$prev" ]]; then
            printf 'selftest: monotonicity failed: prev=%s cur=%s\n' "$prev" "$cur" >&2
            return 1
        fi
        prev="$cur"
    done

    # ------------------------------------------------------------
    # Optional concurrency uniqueness test:
    # - wid requires Z>0 (Z=0 is not unique across processes)
    # - hlc uses unique per-process nodes (works even with Z=0)
    # For concurrency, output order is not guaranteed, so we still sort.
    # ------------------------------------------------------------
    if ((procs > 0)); then
        [[ "$kind" == "wid" || "$kind" == "hlc" ]] || return 1
        ((W > 0)) || return 1
        ((Z >= 0)) || return 1

        local tmp2 dup
        tmp2="$(mktemp)"

        if [[ "$kind" == "wid" && "$Z" -eq 0 ]]; then
            printf 'note: skipping concurrency test for kind=wid Z=0 (not unique across processes)\n' >&2
            rm -f "$tmp2"
        else
            local p
            for ((p=0;p<procs;p++)); do
                (
                    local j node="nodep${p}"
                    for ((j=0;j<per;j++)); do
                        if [[ "$kind" == "wid" ]]; then
                            wid_next "$W" "$Z" "$time_unit"
                        else
                            hlc_next "$node" "$W" "$Z" "$time_unit"
                        fi
                    done
                ) >>"$tmp2" &
            done
            wait

            dup="$(sort "$tmp2" | uniq -d | head -n 1 || true)"
            rm -f "$tmp2"
            [[ -z "$dup" ]] || return 1
        fi
    fi

    return 0
}

main() {
    if [[ $# -gt 0 && "${1:-}" == "__daemon" ]]; then
        shift
        run_canonical "$@"
        exit $?
    fi

    # Canonical mode: KEY=VALUE args
    if [[ $# -gt 0 ]]; then
        local has_kv="false"
        local a
        for a in "$@"; do
            if [[ "$a" == *=* ]]; then
                has_kv="true"
                break
            fi
        done
        if [[ "$has_kv" == "true" ]]; then
            run_canonical "$@"
            exit $?
        fi
    fi

    # Default command is "next" (CLI-friendly)
    local cmd="next"
    if [[ $# -gt 0 ]]; then
        cmd=$1
        shift
    fi

    if [[ "$cmd" == "help" || "$cmd" == "-h" || "$cmd" == "--help" ]]; then
        usage
        exit 0
    fi

    # Dedicated selftest parsing (so we don't break other subcommands)
    if [[ "$cmd" == "selftest" ]]; then
        local n=200
        local procs=0
        local per=10
        local kind="wid"
        local W=4
        local Z=6
        local time_unit="$TIME_UNIT_DEFAULT"
        local _got_procs="false"

        while [[ $# -gt 0 ]]; do
            case "$1" in
            --n)
                [[ $# -ge 2 ]] || die "missing value for --n"
                n=$2
                shift 2
                ;;
            --procs)
                [[ $# -ge 2 ]] || die "missing value for --procs"
                procs=$2
                _got_procs="true"
                shift 2
                ;;
            --per)
                [[ $# -ge 2 ]] || die "missing value for --per"
                per=$2
                shift 2
                ;;
            --kind)
                [[ $# -ge 2 ]] || die "missing value for --kind"
                kind=$2
                shift 2
                ;;
            --W)
                [[ $# -ge 2 ]] || die "missing value for --W"
                W=$2
                shift 2
                ;;
            --Z)
                [[ $# -ge 2 ]] || die "missing value for --Z"
                Z=$2
                shift 2
                ;;
            --time-unit)
                [[ $# -ge 2 ]] || die "missing value for --time-unit"
                time_unit=$2
                shift 2
                ;;
            *) die "invalid argument: $1" ;;
            esac
        done

        is_int "$n" || die "n must be an integer"
        is_int "$procs" || die "procs must be an integer"
        is_int "$per" || die "per must be an integer"
        is_int "$W" || die "W must be an integer"
        is_int "$Z" || die "Z must be an integer"
        if [[ "${_got_procs}" = "false" ]]; then
            procs=$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 2)
            # cap auto-detected procs to avoid very long runs in shell
            ((procs > 4)) && procs=4
        fi
        ((n > 0)) || die "n must be > 0"
        ((procs >= 0)) || die "procs must be >= 0"
        ((per > 0)) || die "per must be > 0"
        ((W > 0)) || die "W must be > 0"
        ((Z >= 0)) || die "Z must be >= 0"
        [[ "$time_unit" == "sec" || "$time_unit" == "ms" ]] || die "time-unit must be sec or ms"
        [[ "$kind" == "wid" || "$kind" == "hlc" ]] || die "kind must be wid or hlc"
        run_selftest "$n" "$procs" "$per" "$kind" "$W" "$Z" "$time_unit"
        exit $?
    fi

    local kind="wid"
    local node="$HLC_DEFAULT_NODE"
    local W=$WID_DEFAULT_W
    local Z=$WID_DEFAULT_Z
    local count=0
    local json=false
    local time_unit="$TIME_UNIT_DEFAULT"

    local id=""
    if [[ "$cmd" == "validate" || "$cmd" == "parse" ]]; then
        [[ $# -ge 1 ]] || die "$cmd requires an id"
        id=$1
        shift
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
        --kind)
            [[ $# -ge 2 ]] || die "missing value for --kind"
            kind=$2
            shift 2
            ;;
        --node)
            [[ $# -ge 2 ]] || die "missing value for --node"
            node=$2
            shift 2
            ;;
        --W)
            [[ $# -ge 2 ]] || die "missing value for --W"
            W=$2
            shift 2
            ;;
        --Z)
            [[ $# -ge 2 ]] || die "missing value for --Z"
            Z=$2
            shift 2
            ;;
        --count)
            [[ $# -ge 2 ]] || die "missing value for --count"
            count=$2
            shift 2
            ;;
        --time-unit)
            [[ $# -ge 2 ]] || die "missing value for --time-unit"
            time_unit=$2
            shift 2
            ;;
        --json)
            json=true
            shift
            ;;
        *) die "invalid argument: $1" ;;
        esac
    done

    [[ "$kind" == "wid" || "$kind" == "hlc" ]] || die "kind must be wid or hlc"
    is_int "$W" || die "W must be an integer"
    is_int "$Z" || die "Z must be an integer"
    ((W > 0)) || die "W must be > 0"
    ((Z >= 0)) || die "Z must be >= 0"
    [[ "$time_unit" == "sec" || "$time_unit" == "ms" ]] || die "time-unit must be sec or ms"

    if [[ "$kind" == "hlc" ]]; then
        valid_node "$node" || die "invalid node"
    fi

    case "$cmd" in
    next)
        if [[ "$kind" == "wid" ]]; then wid_next "$W" "$Z" "$time_unit"; else hlc_next "$node" "$W" "$Z" "$time_unit"; fi
        ;;
    stream)
        if [[ $count -le 0 ]]; then count=10; fi
        local i
        for ((i = 0; i < count; i++)); do
            if [[ "$kind" == "wid" ]]; then wid_next "$W" "$Z" "$time_unit"; else hlc_next "$node" "$W" "$Z" "$time_unit"; fi
        done
        ;;
    validate)
        local ok=false
        if [[ "$kind" == "wid" ]]; then
            validate_wid "$id" "$W" "$Z" "$time_unit" && ok=true
        else
            validate_hlc_wid "$id" "$W" "$Z" "$time_unit" && ok=true
        fi

        if $ok; then
            printf 'true\n'
            exit 0
        else
            printf 'false\n'
            exit 1
        fi
        ;;
    parse)
        if [[ "$kind" == "wid" ]]; then
            parse_wid_fn "$id" "$W" "$Z" "$time_unit" "$json" || exit 1
        else
            parse_hlc_wid_fn "$id" "$W" "$Z" "$time_unit" "$json" || exit 1
        fi
        ;;
    healthcheck)
        local sample ok=false
        if [[ "$kind" == "wid" ]]; then
            sample=$(wid_next "$W" "$Z" "$time_unit")
            validate_wid "$sample" "$W" "$Z" "$time_unit" && ok=true
        else
            sample=$(hlc_next "$node" "$W" "$Z" "$time_unit")
            validate_hlc_wid "$sample" "$W" "$Z" "$time_unit" && ok=true
        fi

        if $json; then
            printf '{"ok":%s,"kind":"%s","W":%s,"Z":%s,"time_unit":"%s","sample_id":"%s"}\n' \
                "$ok" "$kind" "$W" "$Z" "$time_unit" "$(json_escape "$sample")"
        else
            printf 'ok=%s kind=%s sample=%s\n' "$ok" "$kind" "$sample"
        fi

        $ok || exit 1
        ;;
    bench)
        local n start end elapsed ids_per_sec i
        n=$count
        if [[ $n -le 0 ]]; then n=10000; fi
        start=$(date +%s)
        if [[ "$kind" == "wid" ]]; then
            for ((i = 0; i < n; i++)); do
                wid_next "$W" "$Z" "$time_unit" >/dev/null
            done
        else
            for ((i = 0; i < n; i++)); do
                hlc_next "$node" "$W" "$Z" "$time_unit" >/dev/null
            done
        fi
        end=$(date +%s)
        elapsed=$((end - start))
        if [[ $elapsed -le 0 ]]; then elapsed=1; fi
        ids_per_sec=$((n / elapsed))
        printf '{"impl":"sh","kind":"%s","W":%s,"Z":%s,"time_unit":"%s","n":%s,"seconds":%s,"ids_per_sec":%s}\n' \
            "$kind" "$W" "$Z" "$time_unit" "$n" "$elapsed" "$ids_per_sec"
        ;;
    *)
        usage >&2
        die "unknown command: $cmd"
        ;;
    esac
}

main "$@"
